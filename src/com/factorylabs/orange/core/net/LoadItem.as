package com.factorylabs.orange.core.net{	import com.factorylabs.orange.core.IDisposable;	import org.osflash.signals.Signal;	import flash.display.DisplayObject;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Sound;	import flash.media.SoundLoaderContext;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.system.LoaderContext;	import flash.utils.ByteArray;	import flash.utils.getTimer;	/**	 * Provides a simple to use API which serves to simplify the loading of external binary data. 	 *  	 * <p>LoadItems act as "wrapper" classes for Loader objects. It performs common calculations for 	 * percent loaded, bandwidth, latency and remaining and total time. Also makes it easy to  	 * start, pause, stop, and cancel a load operation. Runtime errors are also facilitated by 	 * using LoadItems because no events dispatched from the Loader class go unhandled.</p> 	 * 	 * <hr /> 	 * <p><a target="_top" href="http://github.com/factorylabs/orange-actionscript/MIT-LICENSE.txt">MIT LICENSE</a></p> 	 * <p>Copyright (c) 2004-2010 <a target="_top" href="http://www.factorylabs.com/">Factory Design Labs</a></p> 	 *  	 * <p>Permission is hereby granted to use, modify, and distribute this file  	 * in accordance with the terms of the license agreement accompanying it.</p> 	 * 	 * @author		grantdavis 	 * @version		1.0.0 :: Feb 17, 2010 	 */	public class LoadItem 		implements IDisposable	{		public static const TYPE_DISPLAY	:String = "LoadItemType.display";		public static const TYPE_TEXT		:String = "LoadItemType.text";		public static const TYPE_SOUND		:String = "LoadItemType.sound";		public static const STATE_IDLE				:String = "LoadItemState.idle";		public static const STATE_CONNECTING		:String = "LoadItemState.connecting";		public static const STATE_ACTIVE			:String = "LoadItemState.active";		public static const STATE_PAUSED			:String = "LoadItemState.paused";		public static const STATE_COMPLETE			:String = "LoadItemState.complete";		public static const STATE_FAILED			:String = "LoadItemState.failed";				/**	 	 * The LoadItem.EVENT_PRIORITY_CHANGE constant defines the value of the 		 * <code>type</code> property of the signal event dispatched when this LoadItem has its		 * priority changed. 		 *		 * TODO: Refactor priority into LoaderManager. Has no use on the individual load item.		 * @eventType priorityChange		 */		public static const EVENT_PRIORITY_CHANGE		:String = "LoadItemEvent.priorityChange";//		public static const EVENT_STATE_CHANGE			:String = "LoadItemEvent.stateChange";		public static const EVENT_LOAD_OPEN				:String = "LoadItemEvent.open";		public static const EVENT_LOAD_PROGRESS			:String = "LoadItemEvent.progress";		public static const EVENT_LOAD_INIT				:String = "LoadItemEvent.init";		public static const EVENT_LOAD_COMPLETE			:String = "LoadItemEvent.complete";		public static const EVENT_LOAD_FAILED			:String = "LoadItemEvent.loadFailure";		private var _stateSignal						:Signal;		private var _completeSignal						:Signal;		private var _openSignal							:Signal;		private var _progressSignal						:Signal;		private var _initSignal							:Signal;		private var _errorSignal						:Signal;				public function get stateSignal() :Signal { return _stateSignal; }		public function get completeSignal() :Signal { return _completeSignal; }		public function get openSignal() :Signal { return _openSignal; }		public function get progressSignal() :Signal { return _progressSignal; }		public function get initSignal() :Signal { return _initSignal; }		public function get errorSignal() :Signal { return _errorSignal; }		/**		 * @private		 *///		protected var _signal	:Signal;		/**		 * The URLRequest object associated with this download. 		 * @private		 */		private var _request:URLRequest;				/**		 * An integer value determining the priority of this load. Used by LoaderManager. Higher priority values		 * are loaded before low prioty values. 		 * @private		 *///		private var _priority:int;				/**		 * A LoaderContext object associated with this load. 		 * @private		 */		private var _context:LoaderContext;				/**		 * A custom Loader subclass to use as a substitute for the default Loader class. Class MUST be a subclass of Loader.		 * @private 		 */		private var _loaderType:Class;				/**		 * String value which stores this object's current LoadState value.		 * @private		 */		private var _state:String;				/**		 * Number value from 0-1 indicated the percent of bytes which have been loaded.		 * @private		 */		private var _percentLoaded:Number;				/**		 * Number of bytes remaining to load. 		 * @private		 */		private var _bytesRemaining:int;				/**		 * Current number of bytes loaded. 		 * @private		 */		private var _bytesLoaded:int;				/**		 * Current number of bytes total.		 * @private		 */		private var _bytesTotal:int;				/**		 * Number of bytes which have already been loaded before pause() was called. 		 * @private		 */		private var _bytesCached:int;				/**		 * Number to track the bytes which have been loaded. This is calculated by the current bytes loaded minus the bytes cached. 		 * @private		 */		private var _lastByteCheck:int;				/**		 * Number which tracks when the last byte update occured, in miliseconds. Used to calculate bandwidth.  		 * @private		 */		private var _lastUpdateTime:int;				/**		 * Number of Kbps downloaded per second. 		 * @private		 */		private var _bandwidth:int;				/**		 * Average latency of this load, in miliseconds.		 * @private		 */		private var _latency:int;				/**		 * Keeps track of when the initial start() method is called and 		 * records a true starting time for the entire load. 		 * @private		 */		private var _originalStartTime:int;				/**		 * Keeps track of the time at which start() was called. 		 * @private		 */		private var _startTime:int;		/**		 * Records how long the item has been paused for. 		 * Used to calculate time spent loading. 		 * @private		 */		private var _pausedTime:int;				/**		 * Records when pause() was called and is used to calculate the time paused. 		 * @private		 */		private var _pauseStartTime:int;				/**		 * Determines which type of content will be loaded by this LoadItem. Allowed values are specified constants from the LoadType class.		 * @private 		 */		private var _contentType : String;				/**		 * ILoader object which performs the loading of external data. 		 * @private		 */		private var _loader : ILoader;				/**		 * The SoundContext object to use when loading a sound. Used when the content type is set to TYPE_SOUND.		 * @private		 */		private var _soundContext : SoundLoaderContext;				/**		 * The Object used to send events.		 *///		private var _dispatcher				:EventDispatcher;							/**		 * @return	the current state value for this LoadItem.		 */		public function get state():String { return ( _state ); }		/**		 * TODO: Refactor into LoaderManager.		 * @return	the priority for this LoadItem. Used by LoaderManager.		public function get priority():int { return ( _priority ); }		 */				/**		 * TODO: Refactor into LoaderManager.		 * Sets the priority for this LoadItem. Used by LoaderManager.		 * @param value	Integer value of the new priority. 		public function set priority( $value:int ):void		{			_priority = $value;//			sendEvent( EVENT_PRIORITY_CHANGE );//			sendEvent( LoadItemEvent.PRIORITY_CHANGE );		}		 */				/**		 * @return	the ILoader instance loading the external data. 		 */		public function get loader():ILoader		{			return _loader;		}				/**		 * @return	the URLRequest instance associated with this class. 		 */		public function get request():URLRequest		{			return _request;		}				/**		 * @return	the LoaderContext instance associated with this class. 		 */		public function set context( $value:LoaderContext ):void		{			_context = $value;		}				/**		 * @return	the latency of this connection, in miliseconds. 		 */		public function get latency():int		{			return _latency;		}				/**		 * @return	an integer value of the number of bytes remaining to load. 		 */		public function get bytesRemaining():int		{			return _bytesRemaining;		}		/**		 * @return an integer value of the number of bytes total to load. 		 */		public function get bytesTotal():int		{			return _bytesTotal;		}		/**		 * @return an integer value of the number of bytes loaded.		 */		public function get bytesLoaded():int		{			return _bytesLoaded;		}				/**		 * @return	the percent of bytes loaded by this object, from 0-1.		 */		public function get percentLoaded():Number		{			return _percentLoaded;		}				/**		 * @return	the current Kbps rate for this download. 		 */		public function get bandwidth():int		{			return _bandwidth;		}				/**		 * @return	the total time passed since this load has started, in seconds. 		 */		public function get totalTime():Number		{			return LoadItem.truncateNumber(( getTimer() - _originalStartTime - _pausedTime ) / 1000, 2 );		}				/**		 * @return	the estimated number of seconds remaining to completely load. 		 */		public function get remainingTime():Number		{			var bytesLoadedPerSecond:Number = _bytesLoaded / this.totalTime;			var remainingSeconds:Number = _bytesRemaining / bytesLoadedPerSecond;			return LoadItem.truncateNumber( remainingSeconds, 2 );		}								/**		 * @return	the LoaderContext instance associated with this class. Available when LoadType.SOUND is used. 		 */		public function set soundContext( $value:SoundLoaderContext ):void		{			_soundContext = $value;		}		/**		 * @return	the Sound object used to load an external sound file. Available when LoadType.SOUND is used.		 */		public function get soundContent() : Sound		{			return _loader.data as Sound;		}				/**		 * @return	A string of an externally loaded text file. Available when LoadType.TEXT is used.		 */		public function get textContent() : String		{			return _loader.data as String;		}				/**		 * @return	A ByteArray object. Available when LoadItem.dataFormat is set to URLLoaderDataFormat.BINARY		 */		public function get binaryContent() : ByteArray		{			return _loader.data as ByteArray;		}				/**		 * @return	A URLVariables object. Available when the LoadItem.dataFormat is set to URLLoaderDataFormat.VARIABLES		 */		public function get variablesContent() : URLVariables		{			return _loader.data as URLVariables;		}				/**		 * @return	The DisplayObject object. Available when LoadType.DISPLAY is used.		 */		public function get displayContent() : DisplayObject		{			return _loader.data as DisplayObject;		}				/**		 * @return	The current data format being used for text content. This is available when LoadType.TEXT is used.		 */		public function get dataFormat() : String		{			return ( _loader as TextLoader).dataFormat;		}				/**		 * Sets the URLLoader.dataFormat property when using LoadType.TEXT.		 * @param v_dataFormat	The URLLoaderDataFormat constant to use. 		 */		public function set dataFormat( $dataFormat : String ) : void		{			( _loader as TextLoader).dataFormat = $dataFormat;		}				/**		 * @return	The <code>Signal</code> used for dispatching message events of the load.		 *///		public function get signal() :Signal { return _signal; }											/**		 * Creates a new LoadItem instance. 		 * 		 * @param request		the URLRequest object to associate with this load. 		 * @param priority		[Optional] the priority value to be used by this LoadItem. Used by the LoaderManager.		 * @param LoaderType	[Optional] a subclass of Loader to use for loading this item.		 */		public function LoadItem( $request:URLRequest, $contentType: String = TYPE_DISPLAY, $LoaderType:Class=null )		{			_request = $request;			_contentType = $contentType;			_loaderType = $LoaderType;//			_dispatcher = new EventDispatcher( this );//			_signal = new Signal( String, LoadItem );			initialize();		}		/**		 * Begins the load operation. 		 */		public function start():void		{			_startTime = getTimer();						if ( !_originalStartTime ) 				_originalStartTime = _startTime;											if ( _state == STATE_PAUSED )//			if ( _state == LoadState.PAUSED )			{				var prevPauseTime:int = _pausedTime;				_pausedTime = _startTime -  _pauseStartTime + prevPauseTime;			}						_bytesCached = _bytesLoaded;			updateByteTotal();			load();			setState( STATE_CONNECTING );//			setState( LoadState.CONNECTING );		}				/**		 * Pauses the loading of this item. 		 */		public function pause():void		{						updateByteTotal();			close();			_pauseStartTime = getTimer();			_bytesCached = _bytesLoaded;			setState( STATE_PAUSED );//			setState( LoadState.PAUSED );		}				/**		 * Stops the loading of this item. 		 */		public function stop():void		{						updateByteTotal();			close();			_bytesCached = _bytesLoaded;			setState( STATE_IDLE );//			setState( LoadState.IDLE );		}				/**		 * @return	The string value of this class. 		 */		public function toString():String		{			return "[LoadItem] request: " + _request.url;//			return "[LoadItem] request: " + _request.url + ", priority: " + _priority;		}				/**		 * Performs cleanup and destroy operations to prepare this class for garbage collection.		 */		public function dispose():void		{			close();				removeListeners( _loader.dispatcher );			_loader = null;;		}		/**		 * Performs default initializations when first constructing the class. 		 */		protected function initialize():void		{			_pauseStartTime = getTimer();			_pausedTime = 			_bytesCached = 			_percentLoaded =			_bytesLoaded = 			_bytesTotal = 			_bytesRemaining = 0;			_state = STATE_IDLE;//			_state = LoadState.IDLE;			buildSignals();			buildLoader();		}		/**		 * Creates the signal objects for events and state changes.		 */		protected function buildSignals() :void		{			_stateSignal = new Signal( String );			_completeSignal = new Signal();			_openSignal = new Signal();			_initSignal = new Signal();			_progressSignal = new Signal( int, int );			_errorSignal = new Signal( String );		}		/**		 * Creates the proper loader object for the content type being loaded. 		 */		protected function buildLoader() : void		{			switch ( _contentType )			{				case TYPE_DISPLAY:					_loader = ( _loaderType == null ) ? new DisplayLoader() : new _loaderType() as ILoader;					break;									case TYPE_TEXT:					_loader = ( _loaderType == null ) ? new TextLoader() : new _loaderType() as ILoader;					break;									case TYPE_SOUND:					_loader = ( _loaderType == null ) ? new SoundLoader() : new _loaderType() as ILoader;										break;			}			addListeners( _loader.dispatcher );		}						protected function load() : void		{			switch ( _contentType )			{				case TYPE_SOUND:					_loader.open( _request, _soundContext );					break;									default:					_loader.open( _request, _context );					break;			}		}		/**		 * Attempts to close the Loader object's server connection. 		 */		protected function close():void		{			// if we're loading a sound, the SoundLoader rebuilds the Sound object			// once close() is called, so we have to setup our listeners again.			if ( _contentType == TYPE_SOUND )			{				removeListeners( _loader.dispatcher );				_loader.close();				addListeners( _loader.dispatcher );			}			else _loader.close();		}				/**		 * Adds listeners to the specified loader object.		 * @param loader	Loader to add listeners to.		 */		protected function addListeners( $loader:IEventDispatcher ):void		{			$loader.addEventListener( Event.OPEN, onOpen, false, 0, true );			$loader.addEventListener( Event.UNLOAD, onUnload, false, 0, true );			$loader.addEventListener( Event.INIT, onLoadInit, false, 0, true );			$loader.addEventListener( Event.COMPLETE, onLoadComplete, false, 0, true );			$loader.addEventListener( ProgressEvent.PROGRESS, onProgress, false, 0, true );			$loader.addEventListener( IOErrorEvent.IO_ERROR, onError, false, 0, true );			$loader.addEventListener( SecurityErrorEvent.SECURITY_ERROR, onError, false, 0, true );		}				/**		 * Removes loader listeners from the specified loader object. 		 * @param loader Loader to remove listeners from. 		 */		protected function removeListeners( $loader:IEventDispatcher ):void		{			$loader.removeEventListener( Event.OPEN, onOpen );			$loader.removeEventListener( Event.UNLOAD, onUnload );			$loader.removeEventListener( Event.INIT, onLoadInit );			$loader.removeEventListener( Event.COMPLETE, onLoadComplete );			$loader.removeEventListener( ProgressEvent.PROGRESS, onProgress );			$loader.removeEventListener( IOErrorEvent.IO_ERROR, onError );			$loader.removeEventListener( SecurityErrorEvent.SECURITY_ERROR, onError );		}				/**		 * Sets the internal state of for this LoadItem.		 * @param value	String literal defining the state of this item. Typically these states are defined in the LoadState class. 		 */		protected function setState( $value:String ):void		{			_state = $value;			_stateSignal.dispatch( $value );//			sendEvent( LoadItemEvent.STATE_CHANGE );		}				/**		 * Dipatches LoadItemEvent objects for this class's events. 		protected function sendEvent( $type:String ):void		{			_signal.dispatch( $type, this );//			dispatchEvent( new LoadItemEvent( type, this ));		}		 */				/**		 * Internally updates the byte totals and bandwidth after a progress event.		 */		protected function updateByteTotal():void		{			var curBytesLoaded:int = ( !isNaN( _loader.bytesLoaded )) ? _loader.bytesLoaded : 0;			var curBytesTotal:int = ( !isNaN( _loader.bytesTotal )) ? _loader.bytesTotal : 0;						// check to make sure we use an old bytes loaded if its greater than reported bytes loaded.			// this should help our bandwidth numbers from being totally inflated after pausing.			_bytesLoaded = ( curBytesLoaded > _bytesLoaded ) ? curBytesLoaded : _bytesLoaded;			_bytesTotal = ( curBytesTotal > _bytesTotal ) ? curBytesTotal : _bytesTotal;						_bytesRemaining = _bytesTotal - _bytesLoaded;			_percentLoaded = ( isNaN( _bytesLoaded / _bytesTotal ) ) ? 0 : _bytesLoaded / _bytesTotal;						_lastByteCheck = ( _bytesLoaded - _bytesCached );						// TODO: Get the bandwidth more accurate. For example, if you have two connections open			// and add two new connections which strain the bandwidth available to the two already open,			// the bandwidth report is overinflated and takes a long time to average back down to a correct read.			_lastUpdateTime = getTimer();			_bandwidth = getKbps( _lastByteCheck );		}				
		/**		 * Determines the bandwidth being used by the current load. 		 * @return the Kbps of the current bandwidth.		 */		protected function getKbps( sizeInBytes:Number ):int 		{			var elapsedTimeMS:Number = _lastUpdateTime - _startTime; // time elapsed since start loading swf			var elapsedTime:Number = elapsedTimeMS/1000; //convert to seconds			var sizeInBits:Number = sizeInBytes * 8; // convert Bytes to bits			var sizeInKBits:Number = sizeInBits/1024; // convert bits to kbits			var kbps:Number = ( sizeInKBits/elapsedTime );// * 0.93 ; // IP packet header overhead around 7%			return int( kbps ); // return user friendly number		}				/** 		 * Utility function to truncate a number to the given number of decimal places.         * Number is truncated using the <code>Math.round</code> function.         *            * @param  The number to truncate         * @param  The number of decimals place to preserve.         * @return The truncated number.         */        public static function truncateNumber( raw:Number, decimals:int =2):Number         {           var power : int = Math.pow(10, decimals);           return Math.round(raw * ( power )) / power;        }				/**		 * Handler for when the Loader object has successfully connected to the URL.		 * @param	evt		Event object from dispatching class. 		 */		protected function onOpen( evt:Event ):void		{			if ( !_latency ) _latency = getTimer() - _startTime;			updateByteTotal(); 			setState( STATE_ACTIVE );//			setState( LoadState.ACTIVE );			_openSignal.dispatch();//			sendEvent( EVENT_LOAD_OPEN );//			sendEvent( LoadItemEvent.LOAD_OPEN );		}				/**		 * Handler for progress events from the Loader object.		 * @param	evt		Event object from dispatching class. 		 */		protected function onProgress( $e : ProgressEvent ):void		{			updateByteTotal( ); 			_progressSignal.dispatch( $e.bytesLoaded, $e.bytesTotal );//			sendEvent( EVENT_LOAD_PROGRESS );//			sendEvent( LoadItemEvent.LOAD_PROGRESS );		}				/**		 * Handles an unload event which occurs when the load operation was interrupted before finished,		 * or to clear the contents of the Loader object. 		 * 		 * Dispatched by a LoaderInfo object whenever a loaded object is removed by using the unload()		 * method of the Loader object, or when a second load is performed by the same Loader object		 * and the original content is removed prior to the load beginning. 		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onUnload( $e : Event ):void		{			setState( STATE_IDLE );//			setState( LoadState.IDLE );		}		/**		 * Handler for init event when the properties and methods of a loaded SWF file are accessible.		 * This event is always fired prior to the complete event.		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onLoadInit( $e : Event ):void		{			_initSignal.dispatch();//			sendEvent( EVENT_LOAD_INIT );//			sendEvent( LoadItemEvent.LOAD_INIT );		}		/**		 * Dispatched when data has loaded successfully. Always occurs after the init event. 		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onLoadComplete( $e : Event ):void		{			setState( STATE_COMPLETE );//			setState( LoadState.COMPLETE );			_completeSignal.dispatch();//			sendEvent( EVENT_LOAD_COMPLETE );//			sendEvent( LoadItemEvent.LOAD_COMPLETE );		}				/**		 * Dispatched when an input or output error occurs that causes a load operation to fail		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onError( $e : ErrorEvent ):void		{//			Log.error( "[LoadItem] " + evt.text );			setState( STATE_FAILED );//			setState( LoadState.FAILED );			_errorSignal.dispatch( $e.text );//			sendEvent( EVENT_LOAD_FAILED );//			sendEvent( LoadItemEvent.LOAD_FAILED );		}				/**		 * @inheritDoc		public function dispatchEvent( $e : Event ) :Boolean		{			return _dispatcher.dispatchEvent( $e );		}		 */		/**		 * @inheritDoc		public function addEventListener( type :String, listener :Function, useCapture :Boolean = false, priority :int = 0, useWeakReference :Boolean = false ) :void		{			_dispatcher.addEventListener( type, listener, useCapture, priority, useWeakReference );		}		 */			/**		 * @inheritDoc		public function removeEventListener( type :String, listener :Function, useCapture :Boolean = false ) :void		{			_dispatcher.removeEventListener( type, listener, useCapture );		}		 */		/**		 * @inheritDoc		public function hasEventListener( type :String ) :Boolean		{			return _dispatcher.hasEventListener( type );		}		 */			/**		 * @inheritDoc		public function willTrigger( type :String ) :Boolean		{			return _dispatcher.willTrigger( type );		}		 */	}}