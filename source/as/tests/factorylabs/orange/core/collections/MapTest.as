package tests.factorylabs.orange.core.collections{	import asunit.framework.TestCase;	import com.factorylabs.orange.core.collections.Map;		import flash.utils.Dictionary;		/** 	 * Test methods for the Map test case. 	 *  	 * <p>Copyright 2004-2009 by Factory Design Labs</p>     *      * Permission is hereby granted, free of charge, to any person obtaining     * a copy of this software and associated documentation files (the     * "Software"), to deal in the Software without restriction, including     * without limitation the rights to use, copy, modify, merge, publish,     * distribute, sublicense, and/or sell copies of the Software, and to     * permit persons to whom the Software is furnished to do so, subject to     * the following conditions:     *      * The above copyright notice and this permission notice shall be     * included in all copies or substantial portions of the Software.     *      * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 	 * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> 	 *  	 * @author		Matthew Kitt 	 * @version		1.0.0 :: May 19, 2009 	 */	public class MapTest		extends TestCase	{		private var _map 		:Map;			public function MapTest()		{			super();			createTestData();		}				override public function toString() :String 		{			return "tests.factorylabs.orange.core.collections.MapTest";		}				private function createTestData() :void		{			_map = new Map();			_map.add( "key_1", "value_1" );			_map.add( "key_2", "value_2" );			_map.add( "key_3", "value_3" );			_map.add( "key_4", "value_4" );			_map.add( "key_5", "value_5" );		}				public function test_iterator() :void		{			assertTrue( _map.iterator is Dictionary );					}		public function test_length() :void		{			assertEquals( 5, _map.length );		}				public function test_keys() :void		{			var array	:Array = _map.keys;			var len		:int = array.length;					// maps do not store keys in any order, so we'll check to see if the array has valid keys.						for ( var i :int = 0; i < len; i++ )				assertTrue( _map.hasKey( array[ i ] ) );							assertEquals( _map.length, len );		}				public function test_values() :void		{			var array	:Array = _map.values;			var len		:int = array.length;					// maps do not store values in any order, so we'll check to see if the array has valid values.			for ( var i :int = 0; i < len; i++ )				assertTrue( _map.hasValue( array[ i ] ) );							assertEquals( _map.length, len );		}				public function test_get() :void		{			assertEquals( _map.get( "key_1"), "value_1" );			assertEquals( _map.get( "key_2"), "value_2" );			assertEquals( _map.get( "key_3"), "value_3" );			assertEquals( _map.get( "key_4"), "value_4" );			assertEquals( _map.get( "key_5"), "value_5" );		}				public function test_add() :void		{			var tmp :Map = new Map();			tmp.add( "tmp_key_1", "tmp_value_1" );			assertTrue( tmp.hasKey( "tmp_key_1" ) );			assertTrue( tmp.hasValue( "tmp_value_1" ) );						try			{	// make sure adding the same key throws an error.				tmp.add( "tmp_key_1", "tmp_value_1", false );			}			catch( err :Error )			{	// automatically pass this test since we just caught the error from the try block. 				assertEquals( err.message, "key already in map [tmp_key_1]" );			}		}				public function test_remove() :void		{			var tmp :Map = new Map();			tmp.add( "tmp_key_1", "tmp_value_1" );			tmp.add( "tmp_key_2", "tmp_value_2" );			var value: String = String( tmp.remove( "tmp_key_1" ) );						assertEquals( value, "tmp_value_1" );			assertFalse( tmp.hasKey( "tmp_key_1" ) );		}				public function test_extend() :void		{			var map1 :Map = new Map();			var map2 :Map = new Map();						map1.add( "map1_key1", "map1_value1" );			map1.add( "map1_key2", "map1_value2" );			map2.add( "map2_key1", "map2_value1" );			map2.add( "map2_key2", "map2_value2" );						var extendedMap :Map = Map( map1.extend( map2 ) );						assertTrue( extendedMap.hasKey( "map1_key1" ) );			assertTrue( extendedMap.hasKey( "map1_key2" ) );			assertTrue( extendedMap.hasKey( "map2_key1" ) );			assertTrue( extendedMap.hasKey( "map2_key2" ) );			assertTrue( extendedMap.hasValue( "map1_value1" ) );			assertTrue( extendedMap.hasValue( "map1_value2" ) );			assertTrue( extendedMap.hasValue( "map2_value1" ) );			assertTrue( extendedMap.hasValue( "map2_value2" ) );		}				public function test_hasKey() :void		{			assertTrue( _map.hasKey( "key_1" ) );			assertFalse( _map.hasKey( "key_missing" ) );		}				public function test_hasValue() :void		{			assertTrue( _map.hasValue( "value_1" ) );			assertFalse( _map.hasValue( "value_missing" ) );		}		public function test_clear() :void		{			var tmp :Map = new Map();						tmp.add( "map1_key1", "map1_value1" );			tmp.add( "map1_key2", "map1_value2" );						assertEquals( tmp.length, 2 );			tmp.clear();			assertEquals( tmp.length, 0 );		}				public function test_dispose() :void		{			var tmp :Map = new Map();						tmp.add( "map1_key1", "map1_value1" );			tmp.add( "map1_key2", "map1_value2" );						assertEquals( tmp.length, 2 );			tmp.dispose();			assertEquals( tmp.length, 0 );		}				public function test_clone() :void		{			var tmp		:Map = _map.clone();			var keys	:Array = _map.keys;			var len		:int = keys.length;			for ( var i :int = 0; i < len; i++ )				assertTrue( tmp.hasKey( keys[ i ] ) );		}	}}