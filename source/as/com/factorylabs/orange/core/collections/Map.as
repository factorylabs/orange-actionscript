package com.factorylabs.orange.core.collections{	import com.factorylabs.orange.core.ICloneable;	import com.factorylabs.orange.core.IDisposable;	import flash.utils.Dictionary;		/** 	 *  	 * Maps provide access to stored values through a specific key.	 * 	 * <p>Keys are used as unique identifers to store values. Only one key may exist in each map.</p> 	 *  	 * <p>Copyright 2004-2009 by Factory Design Labs</p>     *      * Permission is hereby granted, free of charge, to any person obtaining     * a copy of this software and associated documentation files (the     * "Software"), to deal in the Software without restriction, including     * without limitation the rights to use, copy, modify, merge, publish,     * distribute, sublicense, and/or sell copies of the Software, and to     * permit persons to whom the Software is furnished to do so, subject to     * the following conditions:     *      * The above copyright notice and this permission notice shall be     * included in all copies or substantial portions of the Software.     *      * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,     * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF     * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND     * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE     * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION     * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION     * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 	 * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> 	 *  	 * @author		Grant, Gabe	 * @version		1.0.0 :: May 9, 2008 	 */	public class Map		implements IMap, IDisposable, ICloneable	{/* * PROPERTIES**************************************************************************************************** */			private var _dict:Dictionary;	/* * PROPERTY ACCESS**************************************************************************************************** */		/**		 * @inheritDoc		 */		public function get iterator():Dictionary		{			return _dict;		}				/**		 * @inheritDoc		 */		public function get length():uint		{			var count:uint = 0;			for(var key:* in _dict)			{ 				key;				count++; 			}			return count;		}				/**		 * @inheritDoc		 */		public function get keys():Array		{			var _keys:Array = [];			for(var key:* in _dict) { _keys.push(key); }			return _keys;		}				/**		 * @inheritDoc		 */		public function get values():Array		{			var _values:Array = [];			for each(var val:* in _dict) { _values.push(val); }			return _values;		}				/**		 * @inheritDoc		 */		public function get(key:*):*		{			return _dict[key];		}						/* * CONSTRUCTOR**************************************************************************************************** */			/**		 * Constructor for the Map.		 * @param weakKeys Boolean whether or not to use a weak reference on the keys.		 */				public function Map(weakKeys:Boolean = false)		{			_dict = new Dictionary(weakKeys);		}				public function toString() : String 		{			return "com.factorylabs.orange.core.collections.Map";		}/* * PUBLIC ACCESS**************************************************************************************************** */		/**		 * @inheritDoc		 */		public function add(key:*,value:*,force:Boolean=false):void		{			if(hasKey(key) && !force) throw new MapError("key already in map ["+key+"]");			_dict[key] = value;		}				/**		 * @inheritDoc		 */		public function remove(key:*):*		{			var val:* = _dict[key];			delete _dict[key];			return val;		}				/**		 * @inheritDoc		 */		public function extend(map:*):IMap		{			var _iterator:* = map;			if (map is Map)  _iterator = Map(map).iterator; 			for(var key:* in _iterator){ add(key,_iterator[key]); }			return this;		}				/**		 * @inheritDoc		public function merge(map:*):IMap		{			var _iterator:* = shallowCopy(map);			if (map is Map)  _iterator = Map(map).iterator; 			// update values for keys			for(var key:* in _iterator)			{ 				_dict[key] = _iterator[key]; 				delete _iterator[key];			}			extend(_iterator);			return this;		}		 */				/**		 * @inheritDoc		 */		public function hasKey(key:*):Boolean		{			for(var _key:* in _dict)			{				if( _key == key)					return true;			}			return false;		}				/**		 * @inheritDoc		 */		public function hasValue(value:*):Boolean		{			for each(var item:* in _dict)			{				if( item == value)					return true;			}			return false;		}				/**		 * @inheritDoc		 */		public function find(func:Function):*		{			for(var key:* in _dict)			{				if( func(key, _dict[key]) )					return _dict[key];			}			return null;		}				/**		 * @inheritDoc		 */		public function each(func:Function):void		{			for(var key:* in _dict)			{				func(key, _dict[key]);			}		}				/**		 * @inheritDoc		 */		public function clear():void		{			for(var key:* in _dict){ delete _dict[key]; }		}				/**		 * delete all keys and values in current map		 */		public function dispose():void		{			clear();		}				/**		 * returns a copy of this Map		 */		public function clone():*		{			var map:Map = new Map();			for(var key:* in IMap( this ).iterator) IMap( map ).add(key, IMap( this ).get(key));			return map;		}		/* * INTERNAL ACCESS**************************************************************************************************** */						/* * EVENT HANDLING**************************************************************************************************** */	}}class MapError	extends Error{	public function MapError(msg:String)	{		super(msg);	}}

