/** * This class provides a simple api for creating and manipulating the arrays necessary for use with the transform property of a movieclip.  * *	To to use this class, simply create an instance of it, apply your transformations using the available methods, and then get the resultant array or transform filter out of it.  *	If you wish you can continue to manipulate the instance of this class and then retrieve another version of the resultant array or filter without affecting the first filter you retrieved.  * *	Copyright 2006 by Factory Design Labs, All Rights Reserved. *	<a href="http://www.factorylabs.com/">www.factorylabs.com</a> * *	@example		The following is an example usage of this class: *	<code> *		// make a transform matrix. *		var vTransMatrix:TransformMatrix = new TransformMatrix(); * *		// set transform sets the location from 0, 0. *		vTransMatrix.setLocation( 275, 200 ); * *		// get an unmanipulated matrix manipulation object *		var vArray1:Array = vTransMatrix.matrix; * *		// manipulate the properties of the matrix array. *		vTransMatrix.adjustLocation( x, y ); *		vTransMatrix.setScale( 200, 200 ); *		vTransMatrix.setShear( 100, 175 ); * *		// get the array out of our matrix manipulation object *		var vArray2:Array = vTransMatrix.matrix; * *		// start a new matrix tween. *		tween2_obj =new MatrixTween( vClip, ApplyMatrix.transform, vArray1, vArray2, 2, Elastic.easeOut ); *	</code> * *	@todo			1. Look at the rotation methods and create rotateAroundSelf() and rotateAroundParent() methods. * * @author 		Matthew Kitt *	@author		beatport *	@version		1.0.0 :: 06.09.2006 *	@since			1.0.0 */package com.factorylabs.orange.core.display.filters{	import flash.display.DisplayObject;
	import flash.geom.Matrix;	
	public class TransformMatrix		extends BasicMatrix	{			/* PROPERTIES ................................................................................ */			/**		 * Identity matrix. A matrix defining a transformed object (u, v, and w are ignored).		 */		private static var IDENTITY:Array =   [1,0,0,																  0,1,0];		/**		 * The matrix being manipulated.		 */		private var _matrix_obj:Matrix;				/* CONSTRUCTOR ............................................................................ */			/**		 *	Instantiate with a movieclip or array from which to extrapolate the current transform and use as the basis for this new transform.		 *	If omitted, the matrix is initialized with the IDENTITY matrix.		 * 		 * @param	vOriginal		[Optional] movieclip with a transformation object or array matrix to initialize with.		 */		public function TransformMatrix( vOriginal:Object=null )		{			// create the matrix to manipulate.			if ( vOriginal is DisplayObject )			{				// get the current transform matrix from the movieclip.				var vTemp:Matrix = DisplayObject( vOriginal ).transform.matrix;								// save the original matrix.				saveOriginal( [ vTemp.a, vTemp.b, vTemp.tx, vTemp.c, vTemp.d, vTemp.ty ] );			}			else if ( vOriginal is Array )			{				// cast object.				var vUse:Array = Array( vOriginal );								// clean up the array.				vUse = clean( vUse, 6 );								// save it.				saveOriginal( vUse );			}			// use an identity matrix.			else saveOriginal( copyArray( TransformMatrix.IDENTITY ));					}				/**		 * @return	the string equivalent of this class. 		 */		override public function toString():String { return "[Object com.factorylabs.fdlCore.filters.TransformMatrix]"; }				/* METHODS ................................................................................... */			/**		 * Sets the x, y location of the current matrix from 0,0. If you pass only one parameter, this will be used to affect both the x and y properties. 		 *	If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		the new x location of the object in pixels from the origin of it's parent movieclip.		 * @param	vY		the new y location of the object in pixels from the origin of it's parent movieclip.		 */		public function setLocation( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.tx : vX;			vY = ( isNaN( vY )) ? vX : vY;						// position them.			_matrix_obj.tx = vX;			_matrix_obj.ty = vY;		}				/**		 * Adjusts the x, y location of the current matrix from its CURRENT location (ie. add the value to the current location). 		 * If you pass only one parameter, this will be used to affect both the x and y properties. 		 *	If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		the new x location of the object in pixels from the origin of it's parent movieclip.		 * @param	vY		the new y location of the object in pixels from the origin of it's parent movieclip.		 */		public function adjustLocation( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.tx : vX;			vY = ( isNaN( vY )) ? vX : vY;						// position them.			_matrix_obj.tx += vX;			_matrix_obj.ty += vY;		}				/**		 * Sets the scale of the current matrix from 0. If you pass only one parameter, this will be used to affect both the x and y properties.		 * If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		[Optional] the new xscale of the matrix where 100% is the current width.		 * @param	vY		[Optional]the new yscale of the matrix where 100% is the current height.		 */		public function setScale( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.a * 100 : vX;			vY = ( isNaN( vY )) ? vX : vY;						// convert to matrix scale.			vX = vX / 100;			vY = vY / 100;						// scale them.			_matrix_obj.a = vX;			_matrix_obj.d = vY;		}				/**		 * Adjusts the scale of the current matrix from its CURRENT scale. If you pass only one parameter, this will be used to affect both the x and y properties.		 *	If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		[Optional] the new xscale of the matrix where 100% is the current width.		 * @param	vY		[Optional] the new yscale of the matrix where 100% is the current height.		 */		public function adjustScale( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.a * 100 : vX;			vY = ( isNaN( vY )) ? vX : vY;						// convert to matrix scale.			vX = vX / 100 - 1;			vY = vY / 100 - 1;						// scale them.			_matrix_obj.a += vX;			_matrix_obj.d += vY;		}				/**		 * Adjusts the rotation of the current matrix.		 * 		 * @param	vDegrees		the number of degrees of rotation.		 *	@usageNote		This method needs to be tested as it may not be performing correctly.		 */		public function setRotation( vDegrees:Number ):void		{			vDegrees = degreesToRadians( vDegrees );			// rotate the matrix			_matrix_obj.rotate( vDegrees );		}				/**		 * Adjusts the rotation of the current matrix. The rotation transformations have not been set up yet. 		 * They need to be setup such that you pass positive or negative degree values.		 * 		 * @param	vDegrees		the number of degrees of rotation.		 *	@usageNote		This method needs to be tested as it may not be performing correctly.		 */		public function adjustRotation( vDegrees:Number ):void		{			// declare variables.			vDegrees = degreesToRadians( vDegrees );			var vTemp:Array = copyArray( TransformMatrix.IDENTITY );						// set the rotation on the temp matrix array.			vTemp[0] = Math.cos( vDegrees ) - 1;			vTemp[1] = Math.sin( vDegrees );			vTemp[3] = - Math.sin( vDegrees );			vTemp[4] = Math.cos( vDegrees ) - 1;						// add the matricies together			matrix = plus( matrix, vTemp );		}				/**		 * Sets the shear/skew of the current matrix from 0. If you pass only one parameter, this will be used to affect both the x and y properties.		 * If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		[Optional] the x shear amount where 100 is the width of the object the matrix is applied to.		 * @param	vY		[Optional] the y shear amount where 100 is the height of the object the matrix is applied to.		 */		public function setShear( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.b * 100 : vX;			vY = ( isNaN( vY )) ? vX : vY;						// convert to matrix scale.			vX = vX / 100 - 1;			vY = vY / 100 -1;						// shear them.			_matrix_obj.b = vX;			_matrix_obj.c = vY;		}				/**		 * Adjusts the shear/skew of the current matrix from the CURRENT value. If you pass only one parameter, this will be used to affect both the x and y properties.		 * If you only want to affect the x or y, you must pass null for the property you do not want to affect.		 * 		 * @param	vX		[Optional] the x shear amount where 100 is the width of the object the matrix is applied to.		 * @param	vY		[Optional] the y shear amount where 100 is the height of the object the matrix is applied to.		 */		public function adjustShear( vX:Number, vY:Number ):void		{			// declare variables.			vX = ( isNaN( vX )) ? _matrix_obj.b * 100 : vX;			vY = ( isNaN( vY )) ? vX : vY;						// convert to matrix shear.			vX = vX / 100 - 1;			vY = vY / 100 - 1;						// shear them.			_matrix_obj.b += vX;			_matrix_obj.c += vY;		}				/**		 *	Converts a number from Degrees to Radians.		 *		 *	@param 	d		degrees (45°, 90°)		 *	@return 	radians (3.14..., 1.57...)		 */		private function degreesToRadians( d:Number ):Number 		{			return d * ( Math.PI / 180 );		}				/**		 *	Convert a number from Radians to Degrees.		 *		 *	@param			radians (3.14..., 1.57...)		 *	@return 		degrees (45°, 90°)		private function radiansToDegrees( r:Number ):Number 		{			return r * ( 180 / Math.PI );		}		 */			/* EVENT HANDLERS ...................................................................... */	/* GETTERS/SETTERS ..................................................................... */			/**		 * @return			the array representing the current transform, overrides the super's implimentation.		 *	@usageNote		the order of the matrix values for TransformMatrix are different from the arguments passed to the Macromedia Matrix class, The Matrix class takes the parameters a, b, c, d, tx, ty		 * 						where as this class takes them in the order a, b, tx, c, d, ty because this is consistent with the rest of the fdlCore matrix classes and is the actual way that the matrix is defined, 		 *							This is also the order that the ApplyMatrix class expects.		 */		override public function get matrix():Array		{			// set the matrix array property.			_matrix_arr = [ _matrix_obj.a, _matrix_obj.b, _matrix_obj.tx, _matrix_obj.c, _matrix_obj.d, _matrix_obj.ty ];						// send a matrix array copy back.			return copyArray( _matrix_arr ); //ArrayUtil.copy( _matrix_arr );		}				/**		 * @param	vNew		sets the matrix array.		 */		override public function set matrix( vNew:Array ):void		{			// set the super.			_matrix_arr = vNew;						// set the matrix object.			_matrix_obj = new Matrix( _matrix_arr[0], _matrix_arr[1], _matrix_arr[3], _matrix_arr[4], _matrix_arr[2], _matrix_arr[5] );		}				/**		 * @return	[Read-Only] a matrix filter constructed with the current matrix data.		 */		public function get filter():Matrix		{			// send back a new matrix filter.			return new Matrix( _matrix_arr[0], _matrix_arr[1], _matrix_arr[3], _matrix_arr[4], _matrix_arr[2], _matrix_arr[5] );				}				/**		 * @return			[Read-Only] the filter representing the original matrix values.		 *	@usageNote		the order of the matrix values for TransformMatrix are different from the arguments passed to the Macromedia Matrix class, The Matrix class takes the parameters a, b, c, d, tx, ty		 * 						where as this class takes them in the order a, b, tx, c, d, ty because this is consistent with the rest of the fdlCore matrix classes and is the actual way that the matrix is defined, 		 *							This is also the order that the ApplyMatrix class expects.		 */		public function get originalFilter():Matrix		{			// send back a matrix filter representing the orignal values.			return new Matrix( _originalMatrix_arr[0], _originalMatrix_arr[1], _originalMatrix_arr[3],			                             _originalMatrix_arr[4], _originalMatrix_arr[2], _originalMatrix_arr[5] );		}				/**		 * @return	[Read-Only] the current matrix x location.		 */		public function get x():Number		{			return _matrix_obj.tx;		}				/**		 * @return	[Read-Only] the current matrix y location.		 */		public function get y():Number		{			return _matrix_obj.ty;		}				/**		 * @return	[Read-Only] the current matrix x scale.		 */		public function get xScale():Number		{			return (_matrix_obj.a + 1) * 100;		}				/**		 * @return	[Read-Only] the current matrix y scale.		 */		public function get yScale():Number		{			return (_matrix_obj.d + 1) * 100;		}				/**		 * @return	[Read-Only] the current matrix rotation.		 *	@usageNote		This method needs to be tested as it may not be performing correctly.		 */		public function get rotation():Number		{			return Math.sin( _matrix_obj.a );				}				/**		 * @return	[Read-Only] the curent matrix x shear.		 */		public function get xShear():Number		{			return (_matrix_obj.b + 1) * 100;		}				/**		 * @return	[Read-Only] the current matrix y shear.		 */		public function get yShear():Number		{			return (_matrix_obj.c + 1) * 100;		}	}}