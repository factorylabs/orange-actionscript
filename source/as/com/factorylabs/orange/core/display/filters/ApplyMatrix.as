/** *	The ApplyMatrix class is an all-static class with methods to provides a consistent api for applying matricies to movieclip filters. * * Both the transform and color filters of a movieclip require an input object with an array of values. However, the way that these properties are applied to the movieclip is not consistent  *	as one is applied to the transform property and the other is added to the array of filters currently applied to that movieclip. This class simply provides a consistent api for applying these * arrays to the different movieclip properties and is very useful in conjunction with the {@link com.factorylabs.fdlCore.effects.TweenMatrix} class. * *	Copyright 2006 by Factory Design Labs, All Rights Reserved. *	<a href="http://www.factorylabs.com/">www.factorylabs.com</a> * *	@example		The following is an example usage of this class: *	<code> *		// create color matricies. *		var vBeginColor:ColorMatrix = new ColorMatrix(); * *		// set the contrast of that matrix. *		vBeginColor.adjustContrast( 0 ); * *		// get the array to send to MatrixTween. *		var vBeginMatrix:Array = vBeginColor.matrix; * *		// do the same for the ending color. *		var vEndColor:ColorMatrix = new ColorMatrix(); *		vEndColor.adjustContrast( 40 ); *		var vEndMatrix:Array = vEndColor.matrix; * *		// start a new matrix tween. *		tween_obj = new MatrixTween( vClip, ApplyMatrix.color, vBeginMatrix, vEndMatrix, .5 ); * *		// make a transform matrix. *		var vTransMatrix:TransformMatrix = new TransformMatrix(); * *		// set transform sets the location from 0, 0. *		vTransMatrix.setLocation( 275, 200 ); * *		// get an unmanipulated matrix manipulation object *		var vArray1:Array = vTransMatrix.matrix; * *		// manipulate the properties of the matrix array. *		vTransMatrix.adjustLocation( x, y ); *		vTransMatrix.setScale( 200, 200 ); *		vTransMatrix.setShear( 100, 175 ); * *		// get the array out of our matrix manipulation object *		var vArray2:Array = vTransMatrix.matrix; * *		// start a new matrix tween. *		tween2_obj =new MatrixTween( vClip, ApplyMatrix.transform, vArray1, vArray2, 2, Elastic.easeOut ); *	</code> * *	TODO:			1. The convolution method has not been tested yet. *	TODO:			2. Create additional methods for applying filters such as bevel and drop shadow. * * @author 		Matthew Kitt *	@author		beatport *	@version		1.0.0 :: 06.08.2006 *	@since			1.0.0 */package com.factorylabs.orange.core.display.filters{	import flash.display.DisplayObject;	import flash.filters.ColorMatrixFilter;	import flash.filters.ConvolutionFilter;	import flash.geom.Matrix;	import flash.geom.Transform;		import com.factorylabs.orange.core.display.filters.errors.ApplyMatrixError;		public class ApplyMatrix	{		/* PROPERTIES ................................................................................ */	/* CONSTRUCTOR ............................................................................ */			/**		 * This is a static class, therefore the constructor is private and empy.		 */		public function ApplyMatrix(){}				/**		 * @return	the string equivalent of this class. 		 */		public function toString():String { return "[Object com.factorylabs.fdlCore.geom.ApplyMatrix]"; }			/* METHODS ................................................................................... */			/**		 * Applies a matrix to the transform property of a movieclip.		 * 		 * @param	vClip			the object who's properties we are affecting.		 * @param	vMatrix		the array containing the data to affect.		 */		public static function transform( vClip:DisplayObject, vMatrix:Array ):void		{			// declare variables.			var vTransform:Transform = vClip.transform;			vTransform.matrix = new Matrix( vMatrix[ 0 ], vMatrix[ 1 ], vMatrix[ 3 ], vMatrix[ 4 ], vMatrix[ 2 ], vMatrix[ 5 ] );						// apply this as the new transform.			vClip.transform = vTransform;		}				/**		 * Applies a new convolution filter to the movieclip being affected.		 * 		 * @param	vClip			the object who's properties we are affecting.		 * @param	vMatrix		the array containing the data to affect.		 */		public static function convolute( vClip:DisplayObject, vMatrix:Array ):void		{			// declare variables.			var vCurrFilters:Array = vClip.filters;						// create the new filter to apply to the filters array.			var vFilter:ConvolutionFilter = new ConvolutionFilter( 0, 0, vMatrix );						// if there are currently no filters on the object... create a new array for the filters.			if ( vCurrFilters.length == 0 ) vCurrFilters = [ vFilter ];						// if there are currently filters on the object.			else			{				try				{					// get the index at which we will reapply the matrix.					var vIndex:Number = findConvolutionFilters( vClip, vCurrFilters );										// apply the matrix to the correct index.					vCurrFilters[ vIndex ] = vFilter;				}				catch ( vError:ApplyMatrixError )				{					// there were no matching filters so add it to the list.					vCurrFilters.push( vFilter );				}			}						// set the new filters array to the movieclip's filters property.			vClip.filters = vCurrFilters;		}				/**		 * Applies a new color filter to the movieclip being affected.		 * 		 * @param	vClip			the object who's properties we are affecting.		 * @param	vMatrix		the array containing the data to affect.		 */		public static function color( vClip:DisplayObject, vMatrix:Array ):void		{			// declare variables.			var vCurrFilters:Array = vClip.filters;						// create the new filter to apply to the filters array.			var vFilter:ColorMatrixFilter = new ColorMatrixFilter( vMatrix );						// if there are currently no filters on the object... create a new array for the filters.			if ( vCurrFilters.length == 0 ) vCurrFilters = [ vFilter ];							// if there are currently filters on the object.			else			{				try				{					// get the index at which we will reapply the matrix.					var vIndex:Number = findColorFilters( vClip, vCurrFilters );										// apply the matrix to the correct index.					vCurrFilters[ vIndex ] = vFilter;				}				catch ( vError:ApplyMatrixError )				{					// there were no matching filters so add it to the list.					vCurrFilters.push( vFilter );				}			}						// set the new filters array to the movieclip's filters property.			vClip.filters = vCurrFilters;		}				/**		 * Searches through the array of filters specified searching for the last filter of the current _matrixType_str. 		 * 		 * @param	vClip			the object who's properties we are affecting.		 * @param	vFilters		the array containing the filter.		 * @return	the index of the last filter that matches the _matrixType_str. null if there are no matches.		 *		 *	@throws	ApplyMatrixError	If no matching color filters were found.		 */		private static function findColorFilters( vClip:DisplayObject, vFilters:Array ):Number		{			// declare variables.			var vTotal:uint = vFilters.length;						// Fixes the recursive loop.			if ( isNaN( vTotal )) return NaN;						// loop backwards through the filters looking for the current filter type.			for( var i:int = vTotal - 1; i >= 0; i-- )			{				// if the current filter is a transform filter.				if ( vFilters[ i ] is ColorMatrixFilter ) return i;			}						// if there were no matching properties, fail.			throw new ApplyMatrixError( "noMatchingFilters", "There are no color filters currently applied to " + vClip );		}				/**		 * Searches through the array of filters specified searching for the last filter of the current _matrixType_str. 		 * 		 * @param	vClip			the object who's properties we are affecting.		 * @param	vFilters		the array containing the filter.		 * @return	the index of the last filter that matches the _matrixType_str. null if there are no matches.		 *		 *	@throws	ApplyMatrixError	If no matching convolution filters were found.		 */		private static function findConvolutionFilters( vClip:DisplayObject, vFilters:Array ):Number		{			// declare variables.			var vTotal:uint = vFilters.length;						// Fixes the recursive loop.			if ( isNaN( vTotal )) return NaN;						// loop backwards through the filters looking for the current filter type.			for( var i:int = vTotal - 1; i >= 0; i-- )			{				// if the current filter is a transform filter.				if ( vFilters[ i ] is ConvolutionFilter ) return i;			}						// if there were no matching properties, fail.			throw new ApplyMatrixError( "noMatchingFilters", "There are no convolution filters currently applied to " + vClip );		}		/* EVENT HANDLERS ...................................................................... */	/* GETTERS/SETTERS ..................................................................... */	}}