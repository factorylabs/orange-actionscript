/** * This class provides a simple api for creating and manipulating the arrays necessary for use with the ColorMatrixFilter property of a movieclip. * *	<p>To to use this class, simply create an instance of it, apply your transformations using the available methods, and then get the resultant array or transform filter out of it. If you wish you can continue to  * manipulate the instance of this class and then retrieve another version of the resultant array or filter without affecting the first filter you retrieved.</p>  * *	<p>The following people are credited with originating all or parts of this code: *	Mario Klingemann :: www.quasimondo.com :: v1.2 *	Grant Skinner :: www.gskinner.com *	Robert Marc Wren :: www.beatport.com</p> * *	Copyright 2006 by Factory Design Labs, All Rights Reserved. *	<a href="http://www.factorylabs.com/">www.factorylabs.com</a> * *	@example		The following is an example usage of this class: *	<listing version="3.0"> *		// create color matricies. * 		var vBeginColor:ColorMatrix = new ColorMatrix(); * *		// set the contrast of that matrix. *		vBeginColor.adjustContrast( 0 ); * *		// get the array to send to MatrixTween. *		var vBeginMatrix:Array = vBeginColor.matrix; * *		// do the same for the ending color. *		var vEndColor:ColorMatrix = new ColorMatrix(); *		vEndColor.adjustContrast( 40 ); *		var vEndMatrix:Array = vEndColor.matrix; * *		// start a new matrix tween. *		tween = new MatrixTween( vClip, ApplyMatrix.color, vBeginMatrix, vEndMatrix, .5 ); *	</listing> * * @author 		Grant Davis * @author 		Matthew Kitt *	@version		1.0.0 :: 07.02.2007 *	@since			1.0.0 */package com.factorylabs.orange.core.display.filters{	import flash.filters.ColorMatrixFilter;	
	public class ColorMatrix		extends BasicMatrix	{			/* PROPERTIES ................................................................................ */			/**		 * Red luminance. RGB to Luminance conversion constants as found on Charles A. Poynton's colorspace-faq:		 * <a href="http://www.faqs.org/faqs/graphics/colorspace-faq/" target="_blank">colorspace-faq</a>		 */		private static var r_lum:Number = 0.212671;				/**		 * Green luminance. RGB to Luminance conversion constants as found on Charles A. Poynton's colorspace-faq:		 * <a href="http://www.faqs.org/faqs/graphics/colorspace-faq/" target="_blank">colorspace-faq</a>		 */		private static var g_lum:Number = 0.715160;				/**		 * Blue luminance. RGB to Luminance conversion constants as found on Charles A. Poynton's colorspace-faq:		 * <a href="http://www.faqs.org/faqs/graphics/colorspace-faq/" target="_blank">colorspace-faq</a>		 */		private static var b_lum:Number = 0.072169;			/*		There seems to be different standards for converting RGB values to Luminance. 		This is the one by Paul Haeberli:		private static var r_lum:Number = 0.3086;		private static var g_lum:Number = 0.6094;		private static var b_lum:Number = 0.0820;	*/				/**		 * Constant for contrast calculations.		 */		private static var DELTA_INDEX:Array = [ 0, 0.01, 0.02, 0.04, 0.05, 0.06, 0.07, 0.08, 0.1,  0.11,																		0.12, 0.14, 0.15, 0.16, 0.17, 0.18, 0.20, 0.21, 0.22, 0.24,																		0.25, 0.27, 0.28, 0.30, 0.32, 0.34, 0.36, 0.38, 0.40, 0.42,																		0.44, 0.46, 0.48, 0.5,  0.53, 0.56, 0.59, 0.62, 0.65, 0.68, 																		0.71, 0.74, 0.77, 0.80, 0.83, 0.86, 0.89, 0.92, 0.95, 0.98,																		1.0,  1.06, 1.12, 1.18, 1.24, 1.30, 1.36, 1.42, 1.48, 1.54,																		1.60, 1.66, 1.72, 1.78, 1.84, 1.90, 1.96, 2.0,  2.12, 2.25, 																		2.37, 2.50, 2.62, 2.75, 2.87, 3.0,  3.2,  3.4,  3.6,  3.8,																		4.0,  4.3,  4.7,  4.9,  5.0,  5.5,  6.0,  6.5,  6.8,  7.0,																		7.3,  7.5,  7.8,  8.0,  8.4,  8.7,  9.0,  9.4,  9.6,  9.8, 																		10.0																	];				/**		 * A matrix defining an unfiltered object.		 */		private static var IDENTITY:Array =   [1,0,0,0,0,																 0,1,0,0,0,																 0,0,1,0,0,																 0,0,0,1,0];		/* CONSTRUCTOR ............................................................................ */			/**		 * Instantiate with the option of defining with an array or another instance of the ColorMatrix class.		 *	If omitted, the matrix is initialized with the IDENTITY matrix.		 * 		 * @param	vMatrix		[Optional] matrix to initialize with.		 */		public function ColorMatrix( vMatrix:Object = null )		{			// if a color _matrix_arr was passed in, use its _matrix_arr as this object's _matrix_arr.			if ( vMatrix is ColorMatrix ) saveOriginal( ColorMatrix( vMatrix ).matrix );						// if an array was passed in, use that as this object's _matrix_arr.			else if ( vMatrix is Array )			{				// cast the array.				var vUse:Array = new Array( vMatrix );								// clean it.				vUse = clean( vUse, 20 );								// save it.				saveOriginal( new Array( vMatrix ));			}				// otherwise, use an identity _matrix_arr.			else saveOriginal( copyArray( IDENTITY ));		}				/**		 * @return	the string equivalent of this class. 		 */		 public override function toString():String { return "[Object com.factorylabs.fdlCore.filters.ColorMatrix]"; }				/* METHODS ................................................................................... */			/**                  		 * Adjust the saturation of this color matrix. Saturation values lie in the range of -100 to 100 where:		 * 	<listing version="3.0">		 * 	-100 means -100% Saturation		 * 	0 is 0% Saturation (aka no change)		 * 	100 is 100% Saturation		 * 	</listing>		 *		 *  <p>Other values outside of this range are possible. Ex: -200% will invert the hue but keep the luminance. 		 *  You may also affect the saturation on a channel basis by passing in values for multiple channels.</p> 		 *  		 *	<p>If only red is passed, this value will be applied to all channels. If all values are specified, 		 *	you will be affecting the saturation of each channel individually. If you only want to affect green, 		 *	pass 0 for red and a value for green.</p>		 *	 		 *	<p>If you only want to affect blue, pass 0 for red and green and then specify a blue value. Any 		 *	parameter that you leave blank or as null will have the red contrast value applied to it. If red is 		 *	null, 0 is the default value.</p>		 * 		 * @param	vR			[Optional] saturation setting for all color channels or for just red if the two other channels are passed.		 * @param	vG		[Optional] saturation setting for the green channel.		 * @param	vB			[Optional] saturation setting for the blue channel.		 */		public function adjustSaturation( vR:Number, vG:Number=NaN, vB:Number=NaN ):void 		{			// adjust values into the matrix number system. Default red to 0 if it was not passed.			vR = ( !isNaN( vR )) ? vR + 1 : 0;			vG = ( !isNaN( vG )) ? vG + 1 : vR;			vB = ( !isNaN( vB )) ? vB + 1 : vR;						// create new luminance rgb set.		    var irlum:Number = (1-vR) * r_lum;			var iglum:Number = (1-vG) * g_lum;			var iblum:Number = (1-vB) * b_lum;						// create the new matrix.			var mat:Array =  [ irlum + vR, iglum, iblum, 0, 0,						  			    irlum, iglum + vG, iblum, 0, 0,						    		    irlum, iglum, iblum + vB, 0, 0,						    		    0,  0,  0 , 1, 0 ];						// concat the the current matrix with this matrix.			concat( mat );		}				/**		 * Adjust the contrast of this color matrix. Contrast values lie in the range of -100 to 100 where:		 * 	-100 means -100% Contrast		 * 	0 is 0% Contrast (aka no change)		 * 	100 is 100% Contrast		 *		 * Other values outside of this range are possible but will only work if you leave at least one channel within this range. You may also affect the contrast on a channel basis by passing in values for multiple channels. 		 *	If only red is passed, this value will be applied to all channels. If all values are specified, you will be affecting the contrast of each channel individually. If you only want to affect green, pass 0/null for red and a value for green. 		 *	If you only want to affect blue, pass 0/null for red and green and then specify a blue value. Any parameter that you leave blank or as null will have the red contrast value applied to it. 		 *	If red is null, 0 is the default value. (This algorithm is from gskinner's ColorMatrix class).		 * 		 * @param	vR			[Optional] contrast setting for all color channels or for just red if the two other channels are passed.		 * @param	vG			[Optional] contrast setting for the green channel.		 * @param	vB			[Optional] contrast setting for the blue channel.		 */		public function adjustContrast( vR:Number, vG:Number=NaN, vB:Number=NaN ):void		{			// adjust values into the matrix number system. Default red to 0 if it was not passed.			vR = ( !isNaN( vR )) ? vR : 0;			vG = ( !isNaN( vG )) ? vG : vR;			vB = ( !isNaN( vB )) ? vB : vR;						// declare variables.			var vChannels:Array = [ vR, vG, vB ];			var vValues:Array = [];						// loop through the channels applying contrast algorithm.			for ( var i:Number = 0; i < 3; i++ )			{				if ( vChannels[ i ] < 0 ) vValues.push( 127+ vChannels[ i ] / 100 * 127 );								else				{					var x:Number = vChannels[ i ] %1;					if ( x == 0 ) vValues.push( DELTA_INDEX[ vChannels[ i ] ] );										// vChannels.push( DELTA_INDEX[( vChannels[i] <<0)] ); 	// this is how the IDE does it...					// but we'll use linear interpolation for more granularity.					else vValues.push( DELTA_INDEX[ ( vChannels[ i ] <<0 ) ] * ( 1 - x ) + DELTA_INDEX[ ( vChannels[ i ] << 0 ) + 1 ] * x );						// convert.					vValues[ i ] = vValues[ i ] * 127 + 127;				}			}						// create the new matrix.			var mat:Array = [ vValues[0]/127,0,0,0,0.5*(127-vValues[0]),									   0,vValues[1]/127,0,0,0.5*(127-vValues[1]),									   0,0,vValues[2]/127,0,0.5*(127-vValues[2]),									   0,0,0,1,0,									   0,0,0,0,1 ];					// apply this to the current matrix.			concat(mat);		}				/**		 * Adjust the brightness of this color matrix. Brightness values lie in the range of -100 to 100 where:		 * 	-1 means -100% Brightness(black)		 * 	0 is 0% Brightness (aka no change)		 * 	1 is 100% Brightness (white).		 *		 * Other values outside of this range are possible. Ex: -2 will invert the colors. You may also affect the brightness on a channel basis by passing in values for multiple channels.		 *	If only red is passed, this value will be applied to all channels. If all values are specified, you will be affecting the brightness of each channel individually.  If you only want to affect green, pass 0/null for red and a value for green. 		 *	If you only want to affect blue, pass 0/null for red and green and then specify a blue value. Any parameter that you leave blank or as null will have the red brightness value applied to it. If red is null, 0 is the default value.		 * 		 * @param	vR			[Optional] brightness setting for all color channels or for just red if the two other channels are passed.		 * @param	vG		[Optional] brightness setting for the green channel.		 * @param	vB			[Optional] brightness setting for the blue channel.		 */		public function adjustBrightness( vR:Number, vG:Number=NaN, vB:Number=NaN ):void 		{			// adjust values into the matrix number system. Default red to 0 if it was not passed.			vR = ( !isNaN( vR )) ? vR * 255 : 0;			vG = ( !isNaN( vG )) ? vG * 255 : vR;			vB = ( !isNaN( vB )) ? vB * 255 : vR;						// create the new matrix array.			var mat:Array =  [1,0,0,0,vR,									   0,1,0,0,vG,									   0,0,1,0,vB,									   0,0,0,1,0 ];	 				// add this new matrix to the current matrix.			concat(mat);		}						/**		 * Adjust the hue of this color matrix. Hue angle lie in the range of -180 to 180 where:		 *		-180 and 180 blues are yellow and red is blue/green.		 *		at -90 blue is blue/green and red is blue/red (purple).		 *		at 90 blue is blue/red (purple) and red is yellow/green.		 *		at -110 blue is green and red is blue.		 *		at 110 blue is red and red is green.		 *		0 is the current hue.		 *		 * @param	angle		hue angle to apply within the range of -180 to 180.		 */		public function adjustHue( angle:Number ):void		{			// declare variables.			angle *= Math.PI/180;			var c:Number = Math.cos( angle );	        var s:Number = Math.sin( angle );	        var f1:Number = 0.213;	        var f2:Number = 0.715;	        var f3:Number = 0.072;						// create the new matrix.	        var mat:Array = [ (f1 + (c * (1 - f1))) + (s * (-f1)), (f2 + (c * (-f2))) + (s * (-f2)), (f3 + (c * (-f3))) + (s * (1 - f3)), 0, 0, 	        							(f1 + (c * (-f1))) + (s * 0.143), (f2 + (c * (1 - f2))) + (s * 0.14), (f3 + (c * (-f3))) + (s * -0.283), 0, 0, 	        							(f1 + (c * (-f1))) + (s * (-(1 - f1))), (f2 + (c * (-f2))) + (s * f2), (f3 + (c * (1 - f3))) + (s * f3), 0, 0, 	        							0, 0, 0, 1, 0, 	        							0, 0, 0, 0, 1];						// add the new matrix to the current matrix.			concat(mat);		}				/**		 * Colorize the object to the rgb number specified and the amount of colorization wanted.		 *	Replaces {@link com.factorylabs.fdlCore.util.ColorUtil#setColor()} method.		 * 		 * @param	rgb 			a hexidecimal color value.		 * @param	amount		[Optional] the amount of colorization desired from 0% - 100%. Defaults to 100%.		 */		public function colorize( rgb:Number, amount:Number=NaN ):void		{			// translate numbers into matrix range.			amount = ( !isNaN( amount )) ? amount : 1;						// declare variables.			var r:Number = ( ( rgb >> 16 ) & 0xff ) / 255;			var g:Number = ( ( rgb >> 8  ) & 0xff ) / 255;			var b:Number = (   rgb         & 0xff ) / 255;			var inv_amount:Number = 1 - amount;						// create the new matrix.			var mat:Array =  [ inv_amount + amount*r*r_lum, amount*r*g_lum,  amount*r*b_lum, 0, 0,						  			 	amount*g*r_lum, inv_amount + amount*g*g_lum, amount*g*b_lum, 0, 0,						   				amount*b*r_lum,amount*b*g_lum, inv_amount + amount*b*b_lum, 0, 0,						    		 	0 , 0 , 0 , 1, 0 ];						// add this to the current matrix.			concat(mat);		}				/**		 * Sets the alpha of the matrix.		 * @param	alpha		the new alpha value from 0 to 1.		 */		public function adjustAlpha( alpha:Number ):void		{			// create the new matrix.			var mat:Array =  [ 1, 0, 0, 0, 0,						  			 	0, 1, 0, 0, 0,						   			 	0, 0, 1, 0, 0,						    		 	0, 0, 0, alpha, 0 ];						// add this matrix to the current matrix.			concat(mat);		}				/**		 * Take out all saturation from the matrix.		 */		public function desaturate():void		{			// create the new matrix.			var mat:Array =  [ r_lum, g_lum, b_lum, 0, 0,						  				 r_lum, g_lum, b_lum, 0, 0,						   				 r_lum, g_lum, b_lum, 0, 0,						    		 	0    , 0    , 0    , 1, 0 ];						// apply that to the current matrix.			concat(mat);		}				/**		 * Invert the colors of this matrix.		 */		public function invert():void		{			// create the new matrix.			var mat:Array =  [ -1 ,  0,  0, 0, 255,						  			  	0 , -1,  0, 0, 255,									  	0 ,  0, -1, 0, 255,									  	0,   0,  0, 1,   0];						// apply that to the matrix.			concat(mat);		}				/**		 * Converts an image to a high contrast (no gray, only black and white) grayscale image.		 * 		 * @param	t		the threshold value from 0 - 255, 255 is almost completely black, 0 is almost completely white.		 *	@usageNote		when using with the TweenMatrix because of the way the threshold algorithm works, it is not possible to tween from a non-threshold value to a threshold value matrix, you must tween between two threshold matricies.		 */		public function threshold( t:Number ):void		{			// create the new matrix.			var mat:Array =  [	r_lum*256, g_lum*256, b_lum*256, 0,  -256*t, 										r_lum*256 ,g_lum*256, b_lum*256, 0,  -256*t, 										r_lum*256, g_lum*256, b_lum*256, 0,  -256*t, 										0, 0, 0, 1, 0]; 						// apply this to the current matrix.			concat(mat);		}				/**		 * Choose a random color matrix with random colors, offsets, but ignoring alpha.		 * @param	amount		[Optional] a centering factor around which the random color will be created values range from 0 to 2		 */		public function randomize( amount:Number=NaN ):void		{			// convert range.			if ( isNaN( amount )) amount = 1;			var inv_amount:Number = 1 - amount;						var r1:Number = inv_amount +  amount * ( Math.random() - Math.random() );			var g1:Number = amount     * ( Math.random() - Math.random() );			var b1:Number = amount     * ( Math.random() - Math.random() );						var o1:Number = amount * 255 * (Math.random() - Math.random());						var r2:Number = amount     * ( Math.random() - Math.random() );			var g2:Number = inv_amount +  amount * ( Math.random() - Math.random() );			var b2:Number = amount     * ( Math.random() - Math.random() );						var o2:Number = amount * 255 * (Math.random() - Math.random());						var r3:Number = amount     * ( Math.random() - Math.random() );			var g3:Number = amount     * ( Math.random() - Math.random() );			var b3:Number = inv_amount +  amount * ( Math.random() - Math.random() );						var o3:Number = amount * 255 * (Math.random() - Math.random());						// create the new matrix.			var mat:Array =  [	r1, g1, b1, 0, o1, 										r2 ,g2, b2, 0, o2, 										r3, g3, b3, 0, o3, 										0 ,  0,  0, 1, 0 ]; 						// apply that to the current matrix.			concat(mat);		}				/**		 *	Set new color values for rgb and alpha. The default for any omitted items is 0.		 * 		 * @param	r		[Optional] red.		 * @param	g		[Optional] green.		 * @param	b		[Optional] blue.		 * @param	a		[Optional] alpha.		 *		 *	@todo		Finish and test the functionality of this method: We advise not using until this has been done.		 */		public function setChannels (r:Number, g:Number, b:Number, a:Number ):void		{			var rf:Number =((r & 1) == 1 ? 1:0) + ((r & 2) == 2 ? 1:0) + ((r & 4) == 4 ? 1:0) + ((r & 8) == 8 ? 1:0); 			if (rf>0) rf=1/rf;			var gf:Number =((g & 1) == 1 ? 1:0) + ((g & 2) == 2 ? 1:0) + ((g & 4) == 4 ? 1:0) + ((g & 8) == 8 ? 1:0); 			if (gf>0) gf=1/gf;			var bf:Number =((b & 1) == 1 ? 1:0) + ((b & 2) == 2 ? 1:0) + ((b & 4) == 4 ? 1:0) + ((b & 8) == 8 ? 1:0); 			if (bf>0) bf=1/bf;			var af:Number =((a & 1) == 1 ? 1:0) + ((a & 2) == 2 ? 1:0) + ((a & 4) == 4 ? 1:0) + ((a & 8) == 8 ? 1:0); 			if (af>0) af=1/af;						var mat:Array =  [(r & 1) == 1 ? rf:0,(r & 2) == 2 ? rf:0,(r & 4) == 4 ? rf:0,(r & 8) == 8 ? rf:0,0,						 		   (g & 1) == 1 ? gf:0,(g & 2) == 2 ? gf:0,(g & 4) == 4 ? gf:0,(g & 8) == 8 ? gf:0,0,						 		   (b & 1) == 1 ? bf:0,(b & 2) == 2 ? bf:0,(b & 4) == 4 ? bf:0,(b & 8) == 8 ? bf:0,0,								   (a & 1) == 1 ? af:0,(a & 2) == 2 ? af:0,(a & 4) == 4 ? af:0,(a & 8) == 8 ? af:0,0];						concat(mat);		}			/* EVENT HANDLERS ...................................................................... */		/* GETTERS/SETTERS ..................................................................... */			/**		 * @return	[Read-Only] a color matrix filter object that uses the current color matrix.		 */		public function get filter():ColorMatrixFilter		{			return new ColorMatrixFilter( _matrix_arr );		}	}}