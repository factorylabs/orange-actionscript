/** *	The ArrayUtil class is an all-static class with methods to extend the capabilities of the Array object. * * <p>Copyright 2004-2009 by Factory Design Labs</p> *  * Permission is hereby granted, free of charge, to any person obtaining * a copy of this software and associated documentation files (the * "Software"), to deal in the Software without restriction, including * without limitation the rights to use, copy, modify, merge, publish, * distribute, sublicense, and/or sell copies of the Software, and to * permit persons to whom the Software is furnished to do so, subject to * the following conditions: *  * The above copyright notice and this permission notice shall be * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> *	 *	@author		Matthew Kitt *	@version	1.0.0 :: Jul 11, 2007 *	@since		1.0.0 */package com.factorylabs.orange.core.util{	import flash.utils.ByteArray;	public final class ArrayUtil	{				public static function copy( source:Array ) : Array		{			var array	:Array = [];			var n		:uint = source.length;						for( var i:uint = 0; i < n; i++ )				array[ i ] = source[ i ];			return array;		}						/**		 * Creates a new unique copy of the array passed in.		 * 		 * <p>Use with caution. Will cause a runtime error if any objects		 * in arr are not native flash datatypes. The bytearry loses a reference		 * to the class info of custom datatypes.</p>		 * 		 * @param	arr		the array to copy.		 * @return	a new array that is a complete copy of the one passed in.		 */		public static function clone( arr:Array ):Array		{			var ba:ByteArray = new ByteArray(); 		    ba.writeObject( arr ); 		    ba.position = 0; 		    return( ba.readObject() );		}				/**		 *	Search and return the index for a specific object in an array.		 *	@param	arr		the array upon which to work.		 *	@param	search	the Object value we are searching for.		 *	@return	the index of the element.		 */		public static function search( arr:Array, search:Object ):int		{			var len:uint = arr.length;			for( var i:int = len; i > -1; --i )			{				if( arr[ i ] == search ) 					return i;			}			return NaN;		}				/**		 *	Retrieve a random element from an Array.		 *	@param	arr		the array to select a random item from.		 *	@return	the object at the random index.		 */		public static function random( arr:Array ):Object		{			var len:int = arr.length;			if ( len > 0 ) 				return arr[ Math.floor( Math.random() * len ) ];				return null;		}				/**		 * Shuffles an existing array.		 * @param	arr		the array to shuffle.		 * @param	unique	true creates a copy of the passed in array, false (default) acts on the original array.		 * @return	the shuffled original (unique = false) or a shuffled copied (unique = true ) array.		 */		public static function shuffle( arr:Array, unique:Boolean = false ):Array		{			if( unique == true ) 				arr = clone( arr );			return arr.sort( function( a:Number, b:Number ):Number{ a; b; return ( Math.floor( Math.random() * 2 ) == 0) ? 1 : -1; } );		}				/**		 *	Check to make sure the position falls within the bounds of the array.		 *	If its greater than the length reset it to the first index, if its less than 0 reset it to the end index. If its within the bounds just send the index back.		 *	@param	arr			the array upon which to work.		 *	@param	position	the current index to check.		 *	@return	the position within the bounds.		 */		public static function loop( arr:Array, position:int ):int		{			var len:int = arr.length;			if( position < 0 )				return len - 1;			else if( position > len - 1 )				return 0;			return position;		}				/**		 *	Determines whether the specified array contains the specified value.		 *	@param	arr		the array that will be checked for the specified value.		 *	@param	value	the object which will be searched for within the array.		 *	@return	true if the array contains the value, false if it does not.		 */			public static function contains( arr:Array, value:Object ):Boolean		{			return ( arr.indexOf( value ) != -1 );		}				/**		 *	Remove all instances of the specified value from the array.		 *	@param	arr		the array from which the value will be removed.		 *	@param	value	the object that will be removed from the array.		 *			 *	TODO: Add a parameter for returning either a copy or a pointer.		 */			public static function remove( arr:Array, value:Object ):void		{			var len:uint = arr.length;			for( var i:int = len; i > -1; i-- )			{				if( arr[ i ] === value )					arr.splice( i, 1 );			}							}			}}