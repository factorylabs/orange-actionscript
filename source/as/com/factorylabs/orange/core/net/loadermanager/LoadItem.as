package com.factorylabs.orange.core.net.loadermanager{	import com.factorylabs.orange.core.gc.IDisposable;	import com.factorylabs.orange.core.logger.Log;	import com.factorylabs.orange.core.net.loadermanager.events.LoadItemEvent;	import com.factorylabs.orange.core.net.loadermanager.loaders.DisplayLoader;	import com.factorylabs.orange.core.net.loadermanager.loaders.ILoader;	import com.factorylabs.orange.core.net.loadermanager.loaders.SoundLoader;	import com.factorylabs.orange.core.net.loadermanager.loaders.TextLoader;		import flash.display.DisplayObject;	import flash.events.ErrorEvent;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.SecurityErrorEvent;	import flash.media.Sound;	import flash.media.SoundLoaderContext;	import flash.net.URLRequest;	import flash.net.URLVariables;	import flash.system.LoaderContext;	import flash.utils.ByteArray;	import flash.utils.getTimer;		/**	 * Provides a simple to use API which serves to simplify the loading of external binary data.  	 *  	 * LoadItems act as "wrapper" classes for Loader objects. It performs common calculations for 	 * percent loaded, bandwidth, latency and remaining and total time. Also makes it easy to  	 * start, pause, stop, and cancel a load operation. Runtime errors are also facilitated by 	 * using LoadItems because no events dispatched from the Loader class go unhandled.  	 *  	 * Copyright 2008 by Factory Design Labs, All Rights Reserved. 	 * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> 	 *  	 * @author		grant 	 * @version		1.0.0 :: Feb 8, 2008 	 * @version		2.0.0 :: August 14, 2008 	 */	public class LoadItem 		implements IEventDispatcher, IDisposable	{/* Properties ......................................................................................*/		/**		 * The URLRequest object associated with this download. 		 */		private var _request:URLRequest;				/**		 * An integer value determining the priority of this load. Used by LoaderManager. Higher priority values		 * are loaded before low prioty values. 		 */		private var _priority:int;				/**		 * A LoaderContext object associated with this load. 		 */		private var _context:LoaderContext;				/**		 * A custom Loader subclass to use as a substitute for the default Loader class. Class MUST be a subclass of Loader. 		 */		private var _loaderType:Class;				/**		 * String value which stores this object's current LoadState value.		 */		private var _state:String;				/**		 * Number value from 0-1 indicated the percent of bytes which have been loaded.		 */		private var _percentLoaded:Number;				/**		 * Number of bytes remaining to load. 		 */		private var _bytesRemaining:int;				/**		 * Current number of bytes loaded. 		 */		private var _bytesLoaded:int;				/**		 * Current number of bytes total.		 */		private var _bytesTotal:int;				/**		 * Number of bytes which have already been loaded before pause() was called. 		 */		private var _bytesCached:int;				/**		 * Number to track the bytes which have been loaded. This is calculated by the current bytes loaded minus the bytes cached. 		 */		private var _lastByteCheck:int;				/**		 * Number which tracks when the last byte update occured, in miliseconds. Used to calculate bandwidth.  		 */		private var _lastUpdateTime:int;				/**		 * Number of Kbps downloaded per second. 		 */		private var _bandwidth:int;				/**		 * Average latency of this load, in miliseconds.		 */		private var _latency:int;				/**		 * Keeps track of when the initial start() method is called and 		 * records a true starting time for the entire load. 		 */		private var _originalStartTime:int;				/**		 * Keeps track of the time at which start() was called. 		 */		private var _startTime:int;		/**		 * Records how long the item has been paused for. 		 * Used to calculate time spent loading. 		 */		private var _pausedTime:int;				/**		 * Records when pause() was called and is used to calculate the time paused. 		 */		private var _pauseStartTime:int;				/**		 * Determines which type of content will be loaded by this LoadItem. Allowed values are specified constants from the LoadType class. 		 */		private var _contentType : String;				/**		 * ILoader object which performs the loading of external data. 		 */		private var _loader : ILoader;				/**		 * The SoundContext object to use when loading a sound. Used when the content type is set to LoadType.SOUND.		 */		private var _soundContext : SoundLoaderContext;				/**		 * The Object used to send events.		 */		private var _dispatcher				:EventDispatcher;			/* Getters/Setters ......................................................................................*/		/**		 * @return	the current state value for this LoadItem.		 */		public function get state():String { return ( _state ); }		/**		 * @return	the priority for this LoadItem. Used by LoaderManager.		 */		public function get priority():int { return ( _priority ); }				/**		 * Sets the priority for this LoadItem. Used by LoaderManager.		 * @param value	Integer value of the new priority. 		 */		public function set priority( value:int ):void		{			_priority = value;			sendEvent( LoadItemEvent.PRIORITY_CHANGE );		}				/**		 * @return	the ILoader instance loading the external data. 		 */		public function get loader():ILoader		{			return _loader;		}				/**		 * @return	the URLRequest instance associated with this class. 		 */		public function get request():URLRequest		{			return _request;		}				/**		 * @return	the LoaderContext instance associated with this class. 		 */		public function set context( value:LoaderContext ):void		{			_context = value;		}				/**		 * @return	the latency of this connection, in miliseconds. 		 */		public function get latency():int		{			return _latency;		}				/**		 * @return	an integer value of the number of bytes remaining to load. 		 */		public function get bytesRemaining():int		{			return _bytesRemaining;		}		/**		 * @return an integer value of the number of bytes total to load. 		 */		public function get bytesTotal():int		{			return _bytesTotal;		}		/**		 * @return an integer value of the number of bytes loaded.		 */		public function get bytesLoaded():int		{			return _bytesLoaded;		}				/**		 * @return	the percent of bytes loaded by this object, from 0-1.		 */		public function get percentLoaded():Number		{			return _percentLoaded;		}				/**		 * @return	the current Kbps rate for this download. 		 */		public function get bandwidth():int		{			return _bandwidth;		}				/**		 * @return	the total time passed since this load has started, in seconds. 		 */		public function get totalTime():Number		{			return LoadItem.truncateNumber(( getTimer() - _originalStartTime - _pausedTime ) / 1000, 2 );		}				/**		 * @return	the estimated number of seconds remaining to completely load. 		 */		public function get remainingTime():Number		{			var bytesLoadedPerSecond:Number = _bytesLoaded / this.totalTime;			var remainingSeconds:Number = _bytesRemaining / bytesLoadedPerSecond;			return LoadItem.truncateNumber( remainingSeconds, 2 );		}								/**		 * @return	the LoaderContext instance associated with this class. Available when LoadType.SOUND is used. 		 */		public function set soundContext( value:SoundLoaderContext ):void		{			_soundContext = value;		}		/**		 * @return	the Sound object used to load an external sound file. Available when LoadType.SOUND is used.		 */		public function get soundContent() : Sound		{			return _loader.data as Sound;		}				/**		 * @return	A string of an externally loaded text file. Available when LoadType.TEXT is used.		 */		public function get textContent() : String		{			return _loader.data as String;		}				/**		 * @return	A ByteArray object. Available when LoadItem.dataFormat is set to URLLoaderDataFormat.BINARY		 */		public function get binaryContent() : ByteArray		{			return _loader.data as ByteArray;		}				/**		 * @return	A URLVariables object. Available when the LoadItem.dataFormat is set to URLLoaderDataFormat.VARIABLES		 */		public function get variablesContent() : URLVariables		{			return _loader.data as URLVariables;		}				/**		 * @return	The DisplayObject object. Available when LoadType.DISPLAY is used.		 */		public function get displayContent() : DisplayObject		{			return _loader.data as DisplayObject;		}				/**		 * @return	The current data format being used for text content. This is available when LoadType.TEXT is used.		 */		public function get dataFormat() : String		{			return ( _loader as TextLoader).dataFormat;		}				/**		 * Sets the URLLoader.dataFormat property when using LoadType.TEXT.		 * @param v_dataFormat	The URLLoaderDataFormat constant to use. 		 */		public function set dataFormat( v_dataFormat : String ) : void		{			( _loader as TextLoader).dataFormat = v_dataFormat;		}				/* Constructor ......................................................................................*/				/**		 * Creates a new LoadItem instance. 		 * 		 * @param request		the URLRequest object to associate with this load. 		 * @param priority		[Optional] the priority value to be used by this LoadItem. Used by the LoaderManager.		 * @param LoaderType	[Optional] a subclass of Loader to use for loading this item.		 */		public function LoadItem( request:URLRequest, contentType:String=LoadType.DISPLAY, LoaderType:Class=null )		{			_request = request;			_contentType = contentType;			_loaderType = LoaderType;			_dispatcher = new EventDispatcher( this );			initialize();		}/* Public Methods .....................................................................................*/		/**		 * Begins the load operation. 		 */		public function start():void		{			_startTime = getTimer();						if ( !_originalStartTime ) 				_originalStartTime = _startTime;											if ( _state == LoadState.PAUSED )			{				var prevPauseTime:int = _pausedTime;				_pausedTime = _startTime -  _pauseStartTime + prevPauseTime;			}						_bytesCached = _bytesLoaded;			updateByteTotal();			load();			setState( LoadState.CONNECTING );		}				/**		 * Pauses the loading of this item. 		 */		public function pause():void		{						updateByteTotal();			close();			_pauseStartTime = getTimer();			_bytesCached = _bytesLoaded;			setState( LoadState.PAUSED );		}				/**		 * Stops the loading of this item. 		 */		public function stop():void		{						updateByteTotal();			close();			_bytesCached = _bytesLoaded;			setState( LoadState.IDLE );		}				/**		 * @return	The string value of this class. 		 */		public function toString():String		{			return "[LoadItem] request: " + _request.url + ", priority: " + _priority;		}				/**		 * Performs cleanup and destroy operations to prepare this class for garbage collection.		 */		public function dispose():void		{			close();				removeListeners( _loader.dispatcher );			_loader = null;;		}/* Private Methods ......................................................................................*/		/**		 * Performs default initializations when first constructing the class. 		 */		protected function initialize():void		{			_pauseStartTime = getTimer();			_pausedTime = 			_bytesCached = 			_percentLoaded =			_bytesLoaded = 			_bytesTotal = 			_bytesRemaining = 0;			_state = LoadState.IDLE;			buildLoader();		}		/**		 * Creates the proper loader object for the content type being loaded. 		 */		protected function buildLoader() : void		{			switch ( _contentType )			{				case LoadType.DISPLAY:					_loader = ( _loaderType == null ) ? new DisplayLoader() : new _loaderType() as ILoader;					break;									case LoadType.TEXT:					_loader = ( _loaderType == null ) ? new TextLoader() : new _loaderType() as ILoader;					break;									case LoadType.SOUND:					_loader = ( _loaderType == null ) ? new SoundLoader() : new _loaderType() as ILoader;										break;			}			addListeners( _loader.dispatcher );		}						protected function load() : void		{			switch ( _contentType )			{				case LoadType.SOUND:					_loader.open( _request, _soundContext );					break;									default:					_loader.open( _request, _context );					break;			}		}		/**		 * Attempts to close the Loader object's server connection. 		 */		protected function close():void		{			// if we're loading a sound, the SoundLoader rebuilds the Sound object			// once close() is called, so we have to setup our listeners again.			if ( _contentType == LoadType.SOUND )			{				removeListeners( _loader.dispatcher );				_loader.close();				addListeners( _loader.dispatcher );			}			else _loader.close();		}				/**		 * Adds listeners to the specified loader object.		 * @param loader	Loader to add listeners to.		 */		protected function addListeners( loader:IEventDispatcher ):void		{			loader.addEventListener( Event.OPEN, onOpen, false, 0, true );			loader.addEventListener( Event.UNLOAD, onUnload, false, 0, true );			loader.addEventListener( Event.INIT, onLoadInit, false, 0, true );			loader.addEventListener( Event.COMPLETE, onLoadComplete, false, 0, true );			loader.addEventListener( ProgressEvent.PROGRESS, onProgress, false, 0, true );			loader.addEventListener( IOErrorEvent.IO_ERROR, onError, false, 0, true );			loader.addEventListener( SecurityErrorEvent.SECURITY_ERROR, onError, false, 0, true );		}				/**		 * Removes loader listeners from the specified loader object. 		 * @param loader Loader to remove listeners from. 		 */		protected function removeListeners( loader:IEventDispatcher ):void		{			loader.removeEventListener( Event.OPEN, onOpen );			loader.removeEventListener( Event.UNLOAD, onUnload );			loader.removeEventListener( Event.INIT, onLoadInit );			loader.removeEventListener( Event.COMPLETE, onLoadComplete );			loader.removeEventListener( ProgressEvent.PROGRESS, onProgress );			loader.removeEventListener( IOErrorEvent.IO_ERROR, onError );			loader.removeEventListener( SecurityErrorEvent.SECURITY_ERROR, onError );		}				/**		 * Sets the internal state of for this LoadItem.		 * @param value	String literal defining the state of this item. Typically these states are defined in the LoadState class. 		 */		protected function setState( value:String ):void		{			_state = value;			sendEvent( LoadItemEvent.STATE_CHANGE );		}				/**		 * Dipatches LoadItemEvent objects for this class's events. 		 */		protected function sendEvent( type:String ):void		{			dispatchEvent( new LoadItemEvent( type, this ));		}				/**		 * Internally updates the byte totals and bandwidth after a progress event.		 */		protected function updateByteTotal():void		{			var curBytesLoaded:int = ( !isNaN( _loader.bytesLoaded )) ? _loader.bytesLoaded : 0;			var curBytesTotal:int = ( !isNaN( _loader.bytesTotal )) ? _loader.bytesTotal : 0;						// check to make sure we use an old bytes loaded if its greater than reported bytes loaded.			// this should help our bandwidth numbers from being totally inflated after pausing.			_bytesLoaded = ( curBytesLoaded > _bytesLoaded ) ? curBytesLoaded : _bytesLoaded;			_bytesTotal = ( curBytesTotal > _bytesTotal ) ? curBytesTotal : _bytesTotal;						_bytesRemaining = _bytesTotal - _bytesLoaded;			_percentLoaded = ( isNaN( _bytesLoaded / _bytesTotal ) ) ? 0 : _bytesLoaded / _bytesTotal;						_lastByteCheck = ( _bytesLoaded - _bytesCached );						// TODO: Get the bandwidth more accurate. For example, if you have two connections open			// and add two new connections which strain the bandwidth available to the two already open,			// the bandwidth report is overinflated and takes a long time to average back down to a correct read.			_lastUpdateTime = getTimer();			_bandwidth = getKbps( _lastByteCheck );		}				
		/**		 * Determines the bandwidth being used by the current load. 		 * @return the Kbps of the current bandwidth.		 */		protected function getKbps( sizeInBytes:Number ):int 		{			var elapsedTimeMS:Number = _lastUpdateTime - _startTime; // time elapsed since start loading swf			var elapsedTime:Number = elapsedTimeMS/1000; //convert to seconds			var sizeInBits:Number = sizeInBytes * 8; // convert Bytes to bits			var sizeInKBits:Number = sizeInBits/1024; // convert bits to kbits			var kbps:Number = ( sizeInKBits/elapsedTime );// * 0.93 ; // IP packet header overhead around 7%			return int( kbps ); // return user friendly number		}				/** 		 * Utility function to truncate a number to the given number of decimal places.         * Number is truncated using the <code>Math.round</code> function.         *            * @param  The number to truncate         * @param  The number of decimals place to preserve.         * @return The truncated number.         */        public static function truncateNumber( raw:Number, decimals:int =2):Number         {           var power : int = Math.pow(10, decimals);           return Math.round(raw * ( power )) / power;        }		/* Loader Handlers......................................................................................*/				/**		 * Handler for when the Loader object has successfully connected to the URL.		 * @param	evt		Event object from dispatching class. 		 */		protected function onOpen( evt:Event ):void		{			if ( !_latency ) _latency = getTimer() - _startTime;			updateByteTotal(); 			setState( LoadState.ACTIVE );			sendEvent( LoadItemEvent.LOAD_OPEN );		}				/**		 * Handler for progress events from the Loader object.		 * @param	evt		Event object from dispatching class. 		 */		protected function onProgress( evt:ProgressEvent ):void		{			updateByteTotal(); 			sendEvent( LoadItemEvent.LOAD_PROGRESS );		}				/**		 * Handles an unload event which occurs when the load operation was interrupted before finished,		 * or to clear the contents of the Loader object. 		 * 		 * Dispatched by a LoaderInfo object whenever a loaded object is removed by using the unload()		 * method of the Loader object, or when a second load is performed by the same Loader object		 * and the original content is removed prior to the load beginning. 		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onUnload( evt:Event ):void		{			setState( LoadState.IDLE );		}		/**		 * Handler for init event when the properties and methods of a loaded SWF file are accessible.		 * This event is always fired prior to the complete event.		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onLoadInit( evt:Event ):void		{			sendEvent( LoadItemEvent.LOAD_INIT );		}		/**		 * Dispatched when data has loaded successfully. Always occurs after the init event. 		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onLoadComplete( evt:Event ):void		{			setState( LoadState.COMPLETE );			sendEvent( LoadItemEvent.LOAD_COMPLETE );		}				/**		 * Dispatched when an input or output error occurs that causes a load operation to fail		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onError( evt:ErrorEvent ):void		{			Log.error( "[LoadItem] " + evt.text );			setState( LoadState.FAILED );			sendEvent( LoadItemEvent.LOAD_FAILED );		}/* * EVENT DISPATCHER HOOKS**************************************************************************************************** */				/**		 * @inheritDoc		 */		public function dispatchEvent( e :Event ) :Boolean		{			return _dispatcher.dispatchEvent( e );		}		/**		 * @inheritDoc		 */		public function addEventListener( type :String, listener :Function, useCapture :Boolean = false, priority :int = 0, useWeakReference :Boolean = false ) :void		{			_dispatcher.addEventListener( type, listener, useCapture, priority, useWeakReference );		}			/**		 * @inheritDoc		 */		public function removeEventListener( type :String, listener :Function, useCapture :Boolean = false ) :void		{			_dispatcher.removeEventListener( type, listener, useCapture );		}		/**		 * @inheritDoc		 */		public function hasEventListener( type :String ) :Boolean		{			return _dispatcher.hasEventListener( type );		}			/**		 * @inheritDoc		 */		public function willTrigger( type :String ) :Boolean		{			return _dispatcher.willTrigger( type );		}	}}