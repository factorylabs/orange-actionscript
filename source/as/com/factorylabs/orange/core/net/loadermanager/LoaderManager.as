package com.factorylabs.orange.core.net.loadermanager{	import com.factorylabs.orange.core.collections.Map;	import com.factorylabs.orange.core.gc.IDisposable;	import com.factorylabs.orange.core.logger.Log;	import com.factorylabs.orange.core.net.loadermanager.events.LoadItemEvent;	import com.factorylabs.orange.core.net.loadermanager.events.LoaderManagerEvent;		import flash.display.Loader;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.media.SoundLoaderContext;	import flash.net.URLRequest;	import flash.system.LoaderContext;	import flash.utils.getTimer;		/**	 * LoaderManager is a robust loading tool which provides a simple API	 * to perform complex loading requirements easy and fast.  	 *  	 * This class allows multiple loads to be queued and prioritized for sequential loading. 	 *  	 * Copyright 2008 by Factory Design Labs, All Rights Reserved. 	 * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> 	 *  	 * @author		grant 	 * @version		1.0.1 :: Feb 8, 2008 	 */	public class LoaderManager //		extends EventDispatcher			implements IEventDispatcher, IDisposable	{/* Properties ......................................................................................*/		/**		 * Dictionary which stores all LoadItems. 		 */		private var _itemMap:Map;		/**		 * Array to store all the LoadItems managed by this class. 		 */		private var _loadItems:Array;				/**		 * Number of items which still need to be loaded. 		 */		private var _remainingItems:int;				/**		 * Total number of items added to management. 		 */		private var _totalItems:int;				/**		 * Number of items which have successfully completed loading. 		 */		private var _loadedItems:int;				/**		 * Number of maximum allowed concurrent downloads.  		 */		private var _maxConnections:uint;				/**		 * Array of LoadItems which are currently loading. 		 */		private var _openConnections:Array;				/**		 * Flag indicated whether the LoaderManager has completely		 * finished loading all of its items. 		 */		private var _isFinished:Boolean;			/**		 * Active bandwidth for user loads, in Kbps.		 */		private var _bandwidth:uint;				/**		 * Percentage of bytes currently loaded. This only tracks open connects or completed connections		 * since the bytesLoaded and bytesTotal properties are not available until a download has started.		 */		private var _bytePercent:Number;				/**		 * Stores the time at which the start() method was called. Used to calculate		 * elapsed and remaining time values. 		 */		private var _startTime:int;				/**		 * Total number of bytes from all managed LoadItems. 		 */		private var _totalBytes:int;				/**		 * Number of loaded bytes from all managed LoadItems.		 */		private var _loadedBytes:int;				/**		 * Number of downloads which have failed to successfully complete. 		 */		private var _failed:int;				/**		 * Average latency calcualted from all managed LoadItems. Stored in miliseconds. 		 */		private var _averageLatency:int;				/**		 * The Object used to send events.		 */		private var _dispatcher				:EventDispatcher;		/* Getters/Setters ......................................................................................*/				/**		 * @return 	the number of total items being managed. 		 */		public function get total():int { return _totalItems; }				/**		 * @return	the number of items remaining to be loaded.		 */		public function get remaining():int { return _remainingItems; }				/**		 * @return	a copy of the internally stored array of load items. 		 */		public function get loadItems():Array { return cloneArray( _loadItems ); }				/**		 * @return	the number of currently active connections. 		 */		public function get connections():int { return _openConnections.length; }				/**		 * @return	the number of finished LoadItems.		 */		public function get isFinished():Boolean { return _isFinished; }				/**		 * @return	the current active bandwidth of all open connections, in Kbps.		 */		public function get bandwidth():uint { return _bandwidth; }				/**		 * @return	the average latency of all loads, in miliseconds. 		 */		public function get averageLatency():uint { return _averageLatency; }				/**		 * @return	the current percent of bytes which have been loaded. Number is from 0-1.		 */		public function get percentLoaded():Number { return _bytePercent; }				/**		 * @return	the number of failed loads.		 */		public function get failed():int { return _failed; }				/**		 * @return	the number of items which have completed loading. 		 */		public function get loaded():int { return  _loadedItems; }				/**		 * @return	the ratio of loaded items over total items in the manager. 		 */		public function get ratioLoaded():Number { return this.loaded / this.total; }				/**		 * @return	the LoadItem with the highest priority. if two items have the same priority, the 		 * item added to the manager first will take precedence. 		 */		public function get highestPriority():int		{			var highest:int = int.MIN_VALUE;			var dl:uint = _loadItems.length;			for( var i:int=0; i < dl; i++ )			{				var item:LoadItem = _loadItems[ i ];				if ( item.priority > highest ) highest = item.priority;			}			return highest;		}				/**		 * @return	the amount of seconds that have elapsed since loading began. 		 */		public function get elapsedTime():Number		{			return truncateNumber(( getTimer() - _startTime ) / 1000, 2 );		}		/* Constructor ......................................................................................*/			/**		 * Builds an instance of the LoaderManager. 		 * 		 * @param maxConnections	the max number of allowed concurrent downloads. 		 */		public function LoaderManager( maxConnections:uint=2 )		{			if ( maxConnections < 1 ) throw new Error( "[LoaderManager] Error: You must use at least one connection" );			_maxConnections = maxConnections;			_dispatcher = new EventDispatcher( this );			initialize();		}/* Public Methods .....................................................................................*/		/**		 * Adds an external load to the manager. 		 * 		 * @param key			an untyped data value which is used to store the new LoadItem by. this key is used as a unique identifier for that 		 * 						load. if a key already exists in our local storage, the add will fail to complete. 		 * @param request 		a URLRequest object for the file to load.		 * @param priority		a integer value which determines the priority of this item. higher priority values are loaded before lower values.  		 * @param LoaderType	[Optional] a Loader subclass to use as the Loader for this item. For example, you could pass "ImageLoader", a subclass of Loader, 		 * 						to perform the load in place of a generic Loader object.		 * @param context		[Optional] a LoaderContext object to use for this load. 		 */		public function add( key:*, request:URLRequest, contentType:String=LoadType.DISPLAY, priority:int=0, context:*=null, LoaderType:Class=null ):LoadItem		{			if ( _itemMap.hasKey( key )) 			{				Log.error( "[LoaderManager] Error: An item already exists with the key: " + key + "." );				return null;			}						var item:LoadItem = buildLoadItem( request, contentType, context, LoaderType );			item.priority = priority;						addListeners( item );			addItem( key, item );						sendEvent( LoaderManagerEvent.ADDED_ITEM, item );			return item;		}		/**		 * Performs an immediate load which bypasses priority. 		 * 		 * Use this method when a file must be loaded immediatley, without waiting for previously added loads to complete first. 		 * 		 * @param key			an untyped data value which is used to store the new LoadItem by. this key is used as a unique identifier for that 		 * 						load. if a key already exists in our local storage, the add will fail to complete. 		 * @param request 		a URLRequest object for the file to load.		 * @param pauseOthers	[Optional] flag determining whether other currently open and active downloads should be paused while loading this item. 		 * @param LoaderType	[Optional] a Loader subclass to use as the Loader for this item. For example, you could pass "ImageLoader", a subclass of Loader, 		 * 						to perform the load in place of a generic Loader object.		 * @param context		[Optional] a LoaderContext object to use for this load. 		 */		public function loadNow( key:*, request:URLRequest, contentType:String=LoadType.DISPLAY, pauseOthers:Boolean=false, context:*=null, LoaderType:Class=null ):Boolean		{			if( _itemMap.hasKey( key ))			{				Log.error( "[LoaderManager] Error: An item already exists with the key: " + key + "." );				return false;			}						if ( pauseOthers ) pauseAll();						var item:LoadItem = buildLoadItem( request, contentType, context, LoaderType );			item.priority = uint.MAX_VALUE;						addListeners( item );			addItem( key, item );						// lose lowest priority connection if we are over the allowed amount. 			if( this.connections+1 > _maxConnections ) 				closeConnection( getLowestPriorityActiveItem() );			item.addEventListener( LoadItemEvent.LOAD_COMPLETE, onResume );			item.addEventListener( LoadItemEvent.LOAD_FAILED, onResume );						// open the connection, now!			openNewConnection( item );						sendEvent( LoaderManagerEvent.ADDED_ITEM, item );			return true;		}				/**		 * Performs an immediate load on an item that has already been added to the manager, which bypasses priority.		 * 		 * Use this method when a file must be loaded immediatley, without waiting for		 * previously added loads to complete first. 		 * 		 * @param key			an untyped data value which is used to store the new LoadItem by. this key is used as a unique identifier for that 		 * 						load. if a key already exists in our local storage, the add will fail to complete. 		 * @param request 		a URLRequest object for the file to load.		 * @param pauseOthers	[Optional] flag determining whether other currently open and active downloads should be paused while loading this item. 		 * @param LoaderType	[Optional] a Loader subclass to use as the Loader for this item. For example, you could pass "ImageLoader", a subclass of Loader, 		 * 						to perform the load in place of a generic Loader object.		 * @param context		[Optional] a LoaderContext object to use for this load. 		 */		public function loadNowByKey( key:*, pauseOthers:Boolean=false ):Boolean		{			// fail if we don't have an object by that key. 			if ( !_itemMap.hasKey( key )) return false;						if ( pauseOthers ) pauseAll();						var item:LoadItem = _itemMap.get( key ) as LoadItem;			item.priority = uint.MAX_VALUE;						// lose lowest priority connection if we are over the allowed amount. 			if( this.connections+1 > _maxConnections ) 				closeConnection( getLowestPriorityActiveItem() );						// open the connection now if its idle.			if ( item.state == LoadState.IDLE ) 				openNewConnection( item );							// resume load if its paused.			else if ( item.state == LoadState.PAUSED )				resume( key );						// otherwise we fail to load because the state must be either complete, failed or already loading.			else return false;						item.addEventListener( LoadItemEvent.LOAD_COMPLETE, onResume );			item.addEventListener( LoadItemEvent.LOAD_FAILED, onResume );						return true;		}		/**		 * Begins loading all items added to the manager. 		 */		public function start():void		{			loadConnections();			_startTime = getTimer();		}				/**		 * Cancels and removes a LoadItem from management. 		 * 		 * @param key	untyped data object which is used to reference the LoadItem created when add() or loadNow() were called. 		 */		public function cancel( key:* ):void		{			if ( !_itemMap.hasKey( key )) return;						var item:LoadItem = _itemMap.get( key );						closeConnection( item );							item.dispose();			remove( key );						_totalItems = _loadItems.length;			_remainingItems = _totalItems - _loadedItems;						checkNext();		}				/**		 * Cancels all items added to the manager.  		 */		public function cancelAll():void		{			var keys:Array = _itemMap.keys;			for (var i:Number=0; i < keys.length; i++) 			{				var key:* = keys[ i ];				cancel( key );			}		}				/**		 * Cancels and removes any LoadItems which have failed to load. 		 */		public function cancelFailedItems():void		{			var keys:Array = _itemMap.keys;			for (var i:Number = 0; i < keys.length; i++) 			{				var key:* = keys[ i ];				var item:LoadItem = getLoadItem( key );				if ( item.state == LoadState.FAILED )					cancel( key );			}		}		/**		 * Pauses a currently active download. 		 * @param key	untyped data object which is used to reference the LoadItem created when add() or loadNow() were called. 		 */		public function pause( key:* ):void		{			if ( key == null ) return;			var item:LoadItem = _itemMap.get( key );			if ( item.state == LoadState.ACTIVE || item.state == LoadState.CONNECTING  ) 				item.pause();		}				/**		 * Pauses all open connections currently downloading. 		 */		public function pauseAll():void		{			for( var i:int = 0; i < _openConnections.length ; i++ )			{				var item:LoadItem = _openConnections[ i ];				if ( item.state == LoadState.ACTIVE || item.state == LoadState.CONNECTING ) 					item.pause();			}		}				/**		 * Resumes downloading of a particular item. 		 * @param key	untyped data object which is used to reference the LoadItem created when add() or loadNow() were called. 		 */		public function resume( key:* ):void		{			if ( key == null ) return;			var item:LoadItem = _itemMap.get( key );			if ( item.state == LoadState.PAUSED ) 				 item.start();		}		/**		 * Resumes loading of all LoadItems which have been paused. 		 */		public function resumeAll():void		{			for( var i:int=0; i<_openConnections.length; i++ )			{				var item:LoadItem = _openConnections[ i ];				if( item.state == LoadState.PAUSED ) 					item.start();			}		}				/**		 * Finds and returns the LoadItem associated with the specified key value. 		 * 		 * @param key	untyped data object which is used to reference the LoadItem created when add() or loadNow() were called. 		 * @return	the LoadItem associated with the specified key.		 */		public function getLoadItem( key:* ):LoadItem		{			return _itemMap.get( key ) as LoadItem;		}				/**		 * Finds and returns the key used to store a particlar LoadItem.		 * Handy for reverse lookup when abstractly handling load events. 		 * 		 * @param item	The LoadItem you wish you return the stored key for.		 */		public function getKeyByLoadItem( item:LoadItem ) : *		{			var keys:Array = _itemMap.keys;			var kl:int = keys.length;			var key:*;			for ( var i : Number = 0; i < kl; i++ )			{				var storedKey:* = keys[ i ];				var storedItem:LoadItem = _itemMap.get( storedKey );				if ( storedItem == item ) 				{					key = storedKey;					break;				}			}			return key;		}		/**		 * Checks to see if there are any idle loads in the manager.  		 * 		 * @return	a boolean value indicated whether or not the manager has idle items in the queue. 		 */		public function hasIdleItems():Boolean		{			return ( getNextIdleItem() == null ) ? false : true;		}				/**		 * Checks to see if there are any paused loads out there that we can		 * start loading. 		 * 		 * @return	a boolean value indicated whether or not the manager has paused items in the queue. 		 */		public function hasPausedItems():Boolean		{			return ( getNextPausedItem() == null ) ? false : true;		}				/**		 * Performs cleanup and destroy operations to prepare this class for garbage collection. 		 */		public function dispose():void		{			for( var i:int = 0; i < _loadItems.length; i++ )			{				var item:LoadItem = _loadItems[ i ];				removeListeners( item );				item.dispose();			}			_loadItems.splice( 0, _loadItems.length-1 );			_openConnections.splice( 0, _openConnections.length-1 );			_openConnections = null;			_itemMap = null;			_loadItems = null;		}		/**		 * @return 	the string value of this class and package name. 		 */		public function toString():String		{			return "[com.factorylabs.components.net.LoaderManager]";		}/* Private Methods ......................................................................................*/		/**		 * Initializes the manager when first created. 		 */		protected function initialize():void		{			_itemMap = new Map();			_loadItems = [];			_openConnections = [];			_totalItems = 0;			_remainingItems = 0;			_failed = 0;			_isFinished = false;		}				private function buildLoadItem( request:URLRequest, contentType:String, context:*, LoaderType:Class ) : LoadItem		{			var item:LoadItem = new LoadItem( request, contentType, LoaderType );			item.priority = ( this.highestPriority >= int.MAX_VALUE ) ? uint.MAX_VALUE : this.highestPriority+1;						if ( context is LoaderContext )				item.context = context as LoaderContext;						if ( context is SoundLoaderContext )				item.soundContext = context as SoundLoaderContext;							return item;		}				/**		 * Adds a new LoadItem to the management.		 * @param key	an untyped data object used to reference the LoadItem from a Map.		 * @param item	the LoadItem to add to management with the associated key. 		 */		protected function addItem( key:*, item:LoadItem ):void		{			_itemMap.add( key, item );			_loadItems.unshift( item );			_loadItems.sort( sortByPriority );			_totalItems = _loadItems.length;			_remainingItems = _totalItems - _loadedItems;		}				/**		 * Opens the next connection in line. 		 */		protected function next():void		{			if ( this.connections >= _maxConnections ) return;			var nextItem:LoadItem = getNextIdleItem();			openNewConnection( nextItem );		}				/**		 * Performs final steps when the manager has completed all loads. 		 */		protected function complete():void		{			_isFinished = true;			sendEvent( LoaderManagerEvent.ALL_LOADS_COMPLETE );		}				/**		 * Checks to see if there can be more connections created or if its finished. 		 */		protected function checkNext():void		{			if ( hasIdleItems() ) loadConnections();			else if (( this.failed + this.loaded ) == this.total ) complete();		}				/**		 * Creates new connections until the max connection limit is reached.		 */		protected function loadConnections():void		{			while( this.connections < _maxConnections ) 			{				if ( hasIdleItems()) next();				else break;			}		}				/**		 * Opens a new connection with the specified LoadItem.		 * @param item	LoadItem to start loading. 		 */		protected function openNewConnection( item:LoadItem ):void		{			_openConnections.push( item );			_openConnections.sortOn( sortByPriority );			item.start();		}				/**		 * Closes a currently active open connection.		 * @param item	LoadItem to stop and close the connection of.  		 * @return		A boolean flag inidicated whether the close completely successfully.		 */		protected function closeConnection( item:LoadItem ):Boolean		{			if ( item.state != LoadState.COMPLETE && item.state != LoadState.FAILED ) item.stop();			for( var i:int=0; i<_openConnections.length; i++ )			{				var tempItem:LoadItem = _openConnections[ i ];				if ( tempItem.loader == item.loader ) 				{					_openConnections.splice( i, 1 );					return true;				}			}			return false;		}				/**		 * Removes a LoadItem from managment.		 * @param key	Untyped data object associated with the LoadItem to remove.		 * @return		A boolean flag inidicated whether the remove completely successfully.		 */		protected function remove( key:* ):Boolean		{			var item:LoadItem = _itemMap.get( key );						if ( item == null ) return false;			_itemMap.remove( key );						for( var i:int=0; i<_loadItems.length; i++ )			{				var tempItem:LoadItem = _loadItems[ i ];				if ( tempItem == item ) 				{					_loadItems.splice( i, 1 );					return true;				}			}			return false;		}		/**		 * Closes the connection of a load which has just completed. Also removes listeners		 * associated with the LoadItem no more listeners for this object are needed.		 * @return		A boolean flag inidicated whether the remove completely successfully.		 */		protected function removeCompleted( loadItem:LoadItem ):Boolean		{			removeListeners( loadItem );			return closeConnection( loadItem );		}				/**		 * Adds LoadItemEvent listeners to a LoadItem.		 * @param loadItem	The LoadItem to listen to events from. 		 */		protected function addListeners( loadItem:LoadItem ):void		{			loadItem.addEventListener( LoadItemEvent.PRIORITY_CHANGE, onPriorityChange, false, 0, true );			loadItem.addEventListener( LoadItemEvent.LOAD_OPEN, onOpen, false, 0, true );			loadItem.addEventListener( LoadItemEvent.LOAD_INIT, onOpen, false, 0, true );			loadItem.addEventListener( LoadItemEvent.LOAD_PROGRESS, onProgress, false, 0, true );			loadItem.addEventListener( LoadItemEvent.LOAD_COMPLETE, onLoadComplete, false, 0, true );			loadItem.addEventListener( LoadItemEvent.LOAD_FAILED, onError, false, 0, true );		}				/**		 * Removes LoadItemEvent listeners from a LoadItem.		 * @param loadItem	The LoadItem to remove events from. 		 */		protected function removeListeners( loadItem:LoadItem ):void		{			loadItem.removeEventListener( LoadItemEvent.PRIORITY_CHANGE, onPriorityChange );			loadItem.removeEventListener( LoadItemEvent.LOAD_OPEN, onOpen );			loadItem.removeEventListener( LoadItemEvent.LOAD_INIT, onOpen );			loadItem.removeEventListener( LoadItemEvent.LOAD_PROGRESS, onProgress );			loadItem.removeEventListener( LoadItemEvent.LOAD_COMPLETE, onLoadComplete );			loadItem.removeEventListener( LoadItemEvent.LOAD_FAILED, onError );						// remove listeners in case it was a loadNow job. 				// TODO: Better way to make sure they get cleaned up?			loadItem.removeEventListener( LoadItemEvent.LOAD_FAILED, onResume );			loadItem.removeEventListener( LoadItemEvent.LOAD_COMPLETE, onResume );		}						/**		 * Utility method to dispatch a LoaderManagerEvent.		 * @param type 	String inidicator of the type of event to dispatch.		 * @param item	[Optional] The LoadItem associated with the event. 		 */		protected function sendEvent ( type:String, item:LoadItem=null ):void		{			dispatchEvent( new LoaderManagerEvent( type, item, _loadedItems, _totalItems, _loadedBytes, _totalBytes ));		}				/**		 * @return the first available LoadItem that is in an idle state. 		 */		protected function getNextIdleItem():LoadItem		{			for( var i:int=0; i<_loadItems.length; i++ )			{				var item:LoadItem = _loadItems[ i ];				if( item.state == LoadState.IDLE ) return item;			}			return null;		}				/**		 * @return 	the first available LoadItem that is in an idle state. 		 */		protected function getNextPausedItem():LoadItem		{			for( var i:int=0; i<_loadItems.length; i++ )			{				var item:LoadItem = _loadItems[ i ];				if( item.state == LoadState.PAUSED ) return item;			}			return null;		}				/**		 * @return	the lowest priority of the open connections. 		 */		protected function getLowestPriorityActiveItem():LoadItem		{			return _openConnections[ _openConnections.length-1 ] as LoadItem;		}				/**		 * @return	the associated LoadItem with a particular Loader instance. returns null if none found. 		 */		protected function getLoadItemFromLoader( loader:Loader ):LoadItem		{			for( var i:int = 0; i < _loadItems.length ; i++ )			{				var item:LoadItem = _loadItems[ i ];				if ( item.loader == loader ) 				{					return item;				}			}			return null;		}						/**		 * Sorts an array based on the priority property from highest to lowest. 		 */		protected function sortByPriority( a:LoadItem, b:LoadItem ):int		{			if ( a.priority > b.priority ) return -1;			else if ( a.priority < b.priority ) return 1;			else return 0;		}				/**		 * Internally updates totals and percentages of all loads. 		 */		protected function updateProgress():void		{			var loaded:int = 0;			var total:int = 0;			var percent:Number = 0;			var numCounted:int = 0;						for( var i:int=0; i < _loadItems.length; i++ )			{				var item:LoadItem = _loadItems[ i ];				loaded += item.bytesLoaded;				total += item.bytesTotal;												if ( item.state != LoadState.FAILED )				{					percent += item.percentLoaded;					numCounted++;				}			}						_loadedBytes = loaded;			_totalBytes = total;			_bytePercent = percent / numCounted;		}				/**		 * Internally updates the active bandwidth for all open connections.		 */		protected function updateBandwidth():void		{			var activeBandwidth:int = 0;			for( var i:int = 0; i < _openConnections.length; i++ )			{				var item:LoadItem = _openConnections[ i ];				if ( item.state == LoadState.ACTIVE )				{					activeBandwidth += item.bandwidth;				}			} 			// record the TOTAL bandwidth of active items.			_bandwidth = activeBandwidth;		}				/**		 * Averages the latency value from all LoadItems. 		 */		protected function updateAverageLatency():void		{			var latencyTotal:int = 0;			var numCounted:int = 0;			for( var i:int=0; i<_loadItems.length; i++ )			{				var item:LoadItem = _loadItems[ i ];				if ( item.state == LoadState.PAUSED || item.state == LoadState.ACTIVE || item.state == LoadState.COMPLETE )				{					latencyTotal += item.latency;					numCounted++;				} 			} 			_averageLatency = latencyTotal / numCounted;		}				/**		 * Updates the number of remaining items left to load. 		 */		protected function updateRemaining():void		{			_remainingItems = _totalItems - ( _loadedItems + _failed );		}				/** Utility function to truncate a number to the given number of decimal places.         *   @description          *   Number is truncated using the <code>Math.round</code> function.         *            *   @param  The number to truncate         *   @param  The number of decimals place to preserve.         *   @return The truncated number.         */        public static function truncateNumber( raw:Number, decimals:int =2):Number         {           var power : int = Math.pow(10, decimals);           return Math.round(raw * ( power )) / power;        }                /**		 * Creates a new unique copy of the array passed in.		 * 		 * @param	arr		the array to copy.		 * @return	a new array that is a complete copy of the one passed in.		 */        private function cloneArray( arr:Array ):Array		{			var array:Array = [];			var ln:int = arr.length;			for ( var i : Number = 0; i < ln; i++ ) { array[ i ] = arr[ i ]; }			return array;		}		/* Loader Handlers......................................................................................*/						/**		 * Handles priority change events from LoadItems. 		 * @param	evt		Event object from dispatching class. 		 */		protected function onPriorityChange( evt:LoadItemEvent ):void		{			_loadItems.sort( sortByPriority );			start();		}		/**		 * Handles a LoadItem resuming a download after being paused. 		 * @param	evt		Event object from dispatching class. 		 */		protected function onResume( evt:LoadItemEvent ):void		{			evt.loadItem.removeEventListener( LoadItemEvent.LOAD_COMPLETE, onResume );			evt.loadItem.removeEventListener( LoadItemEvent.LOAD_FAILED, onResume );			resumeAll();		}				/**		 * Handles a LoadItem open event, meaning the download has successfully started. 		 * @param	evt		Event object from dispatching class. 		 */		protected function onOpen( evt:LoadItemEvent ):void		{			updateProgress();			updateAverageLatency();			sendEvent( LoaderManagerEvent.LOAD_STARTED, evt.loadItem );		}		/**		 * Handles progress events from LoadItems. 		 */		protected function onProgress( evt:LoadItemEvent ):void		{			updateProgress();			updateBandwidth();			sendEvent( LoaderManagerEvent.LOAD_PROGRESS, evt.loadItem );		}				/**		 * Dispatched when data has loaded successfully. Always occurs after the init event. 		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onLoadComplete( evt:LoadItemEvent ):void		{			_loadedItems++;			updateRemaining();					updateProgress();			removeCompleted( evt.loadItem );			sendEvent( LoaderManagerEvent.LOAD_COMPLETE, evt.loadItem );			checkNext();		}				/**		 * Dispatched when an input or output error occurs that causes a load operation to fail		 * @param	evt		Event object from dispatching Loader. 		 */		protected function onError( evt:LoadItemEvent ):void		{			_failed++;			updateRemaining();			updateProgress();			removeCompleted( evt.loadItem );			sendEvent( LoaderManagerEvent.LOAD_FAILED, evt.loadItem );			checkNext();		}/* * EVENT DISPATCHER HOOKS**************************************************************************************************** */				/**		 * @inheritDoc		 */		public function dispatchEvent( e :Event ) :Boolean		{			return _dispatcher.dispatchEvent( e );		}		/**		 * @inheritDoc		 */		public function addEventListener( type :String, listener :Function, useCapture :Boolean = false, priority :int = 0, useWeakReference :Boolean = false ) :void		{			_dispatcher.addEventListener( type, listener, useCapture, priority, useWeakReference );		}			/**		 * @inheritDoc		 */		public function removeEventListener( type :String, listener :Function, useCapture :Boolean = false ) :void		{			_dispatcher.removeEventListener( type, listener, useCapture );		}		/**		 * @inheritDoc		 */		public function hasEventListener( type :String ) :Boolean		{			return _dispatcher.hasEventListener( type );		}			/**		 * @inheritDoc		 */		public function willTrigger( type :String ) :Boolean		{			return _dispatcher.willTrigger( type );		}			}}