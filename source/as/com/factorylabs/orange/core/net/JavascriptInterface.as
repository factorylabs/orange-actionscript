package com.factorylabs.orange.core.net{	import com.factorylabs.orange.core.logger.Log;		import flash.events.TimerEvent;	import flash.external.ExternalInterface;	import flash.utils.Timer;	import flash.utils.getTimer;		/** 	 * This class handles outgoing Javascript calls and determines whether or not	 * FSCommand should be used to avoid the IE "click" sound. 	 * 	 * <p>Since the user of <code>ExternalInterface</code> triggers the "click" sound from Internet Explorer,	 * this class serves as a wrapper for using ExternalInterface and substitutes the use of 	 * <code>ExternalInterface.call()</code> with <code>fscommand</code> to silently perform the same 	 * javascript call.</p>	 * 	 * <p><b>NOTE: </b>In order to successfully use <code>JavascriptInterface</code>, a function needs to exist	 * on the HTML page containing this Flash movie to capture all javascript calls. This function name is a	 * combination of the player ID and "_DoFSCommand". For example, on an HTML page with a movie with the id	 * value of "player" would need a javascript function named <code>player_DoFSCommand</code>. This function	 * has two arguments,  1) the command string, which is run through an <code>eval()</code> method to properly execute the javascript call 	 * and 2) a string value of "true" or "false" inidcating whether to use callbacks or not. By default, below	 * is the <code>player_DoFSCommand</code> function body:</p>	 * <listing>	 * // This javascript function acts as a handler for all fscommands	 * // called by the flash app. The prefix of the function name must	 * // match the id given to the embedded flash object.	 * // The command passed to this function should be a complete string	 * // of the javascript call. i.e. command = functionName( 'arg 1', arg2, "arg3" );	 * function player_DoFSCommand( command, useCallback )	 * {	 * 		// pull out the function name from the command to run.	 * 		var functionName = command.slice( 0, command.indexOf( "(" ));	 * 		// store returned value from evaluated command	 * 		var returnedValue = eval( command );	 * 			 * 		// if there is a returned value and we are set to use callbacks, send it back to Flash.	 * 		if ( returnedValue != undefined && useCallback == "true" )	 * 		{	 * 			// 1) grab flash movie element.	 * 			// 2) grab reference to the function to call in the Flash movie.	 * 			// 3) apply the function and pass an array of arguments (the returned value).	 * 			var movie = document.getElementById( "player" );	 * 			var movieFunction = eval( "movie." + functionName );	 * 			movieFunction.apply( movieFunction, [ returnedValue ]);	 * 		}	 * 	}	 * </listing> 	 * 	 * <p>Below is an example of Actionscript what will call a Javascript method named <code>test</code>	 * and get the returned results in a handler function.	 * 	 * <p><b>Javascript:</b></p>	 * <listing>	 * function test( arg1, arg2, arg3 )	 * {	 * 		return [ arg1, arg2, arg3 ];	 * }</listing>	 * 	 * <p><b>Actionscript:</b></p>	 * <listing>	 * JavascriptInterface.call( "test", handleCallback, "one", "two", 3 );	 * 	 * private function handleCallback( value ):void	 * {	 * 		// value returns native array type: "one", "two", 3	 * }</listing> 	 *  	 * Copyright 2008 by Factory Design Labs, All Rights Reserved. 	 * <a href="http://www.factorylabs.com/">www.factorylabs.com</a> 	 * 	 * @author		grant 	 * @version		1.1	May 5th, 2008 	 * @version 	2.0 May 21st, 2008 	 * @version		2.1 May 27th, 2008 		- Added priorities 	 */	public class JavascriptInterface 	{		/**		 * Number of miliseconds between each Javascript call. 		 */		private static const JS_CALL_DELAY:int = 500;				/**		 * Array to queue javascript calls.		 */		private static var _jsCalls:Array = [];				/**		 * Timer instance.		 */		private static var _jsTimer:Timer;				/**		 * Tracks the last time a call was made. We track this to make sure no more than 1 call goes		 * out within the <code>JS_CALL_DELAY</code> timeframe.		 */		private static var _lastCallTime:int;	/* Public Methods ......................................................................................*/				/**		 * This method checks to see if the user is using Internet Explorer and if the user is on IE,		 * the javascript call is made through FSCommand to avoid trigger the annoying IE "click" sound.		 * 		 * <p>This method serves as an alternative to directly using External Interface.</p>		 * 		 * <p><b>NOTE:</b> The HTML page containing the flash movie must have a handler function for all FSCommands.		 * The handler function must be named using the object ID of the embedded flash movie.</p>		 * 		 * <p>For example, if your movie is embedded with the name of "mainFlash", the javascript handler would be named:		 * 		<br><code>mainFlash_DoFScommand<code></p>		 * 		 * @param functionName	Javascript function to call.		 * @param callback		[Optional] Function to handle any returned values from the javascript function.		 * @param arguments 	[Optional] Array of arguments to pass to javascript function.		 */		public static function call( functionName:String, priority:int=0, callback:Function=null, ...arguments ):void		{			// don't make any calls if we don't have javascript access.			if ( !ExternalInterface.available ) return;						var currentTime:int = getTimer();						// make sure timer is built.			if ( _jsTimer == null ) buildTimer();						// create and populate the javascript call object.			var jsCall:JavascriptCall = new JavascriptCall();			jsCall.functionName = functionName;			jsCall.callback = callback;			jsCall.args = arguments;			jsCall.priority = priority;						// store javascript call.			_jsCalls.push( jsCall );			// sort array on priority. 			_jsCalls.sort( sortByPriority );						// if there weren't any previously queued items, 			// go ahead and make the call right away.			if ( _jsCalls.length == 1 && currentTime - _lastCallTime > JS_CALL_DELAY )			{				nextCall();			}			// start the queue.			else startQueue();						// record the time this call was fired.			_lastCallTime = currentTime;		}				/**		 * Tries to open up a pop-up window. If it fails the specified alert message will appear in the browser window.		 * 		 * @param url			The URL of the pop-up html.		 * @param windowName	The window name of the pop-up.		 * @param options		The options for the window.		 * @param alertMessage	[Optional] The message to display if a pop-up was not able to successfully open.		 */		public static function openPopup( url:String, windowName:String, options:String, alertMessage:String = 'A pop-up from this site was unable to open. Please disable your pop-up blocker.' ) : void		{			var openPopupWindow:XML = 			<script>				<![CDATA[					function( url, windowName, options, alertMessage )					{						var popupWindow = window.open( url, windowName, options );						if( !popupWindow ) setTimeout( alert, 1000, new Array( alertMessage ) );					}				]]>			</script>;			call( openPopupWindow, 0, null, url, windowName, options, alertMessage );		}		/* Private Methods ......................................................................................*/				/**		 * Builds the timer object that will run an infinite number of times.		 */		private static function buildTimer():void		{			// create the timer object for sending calls. 			_jsTimer = new Timer( JS_CALL_DELAY, 0 );			_jsTimer.addEventListener( TimerEvent.TIMER, onTick );		}			/**		 * Builds and starts the call timer if not already built and running. 		 */		private static function startQueue():void		{			// start timer if its not running. 			if ( !_jsTimer.running ) _jsTimer.start();		}				/**		 * Checks the remaining items in queue. If there are no more items,		 * the Timer triggering call events will be stopped. 		 */		private static function checkQueue():void		{			// stop the timer if we're out of calls.			if ( _jsCalls.length <= 0 ) 			{				_jsTimer.stop();			}		}				/**		 * Performs the next javscript call in sequence. 		 */		private static function nextCall():void		{			// pull first item from the queue.			var jsCall:JavascriptCall = _jsCalls.shift();						// create an arguments array to apply on the ExternalInterface.call method. 			var args:Array = [ jsCall.functionName ];						// run the call() method and apply our arguments on it. store any returned value from the call. 			var returnedValue:* = ExternalInterface.call.apply( ExternalInterface, args.concat( jsCall.args ));						// send returned value to the callback function 			if ( jsCall.callback != null )				jsCall.callback.apply( jsCall.callback, [ returnedValue ]);						Log.core( "[JavascriptInterface] nextCall()", "priority: " + jsCall.priority + ", " + jsCall.functionName + "( " + jsCall.args + " );" );						// check if there are remaining items in queue. 			checkQueue();		}				/**		 * Utility method to sort the internal calls based on priority levels from highest to lowest. 		 */		private static function sortByPriority( a:JavascriptCall, b:JavascriptCall ):int		{			if ( a.priority > b.priority ) return -1;			else if ( a.priority == b.priority ) return 0;			else return 1;		}		/* Event Handlers ......................................................................................*/						/**		 * Handles each tick of the timer and issues an ExternalInterface call from the queue. 		 * @param	evt		Event from the dispatching Timer object. 		 */		private static function onTick( evt:TimerEvent ):void		{			nextCall();		}	}}